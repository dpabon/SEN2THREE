#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Oct 30 09:06:17 2013 by generateDS.py version 2.10b.
#

import sys
import getopt
import re as re_
import base64
import datetime as datetime_

etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class EarthExplorerFileType(GeneratedsSuper):
    """EOFFS standard File type"""
    subclass = None
    superclass = None
    def __init__(self, extensiontype_=None):
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if EarthExplorerFileType.subclass:
            return EarthExplorerFileType.subclass(*args_, **kwargs_)
        else:
            return EarthExplorerFileType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EarthExplorerFileType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EarthExplorerFileType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EarthExplorerFileType'):
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EarthExplorerFileType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='EarthExplorerFileType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class EarthExplorerFileType


class EarthExplorerHeaderType(GeneratedsSuper):
    """EOFFS header type"""
    subclass = None
    superclass = None
    def __init__(self, Fixed_Header=None, Variable_Header=None):
        self.Fixed_Header = Fixed_Header
        self.Variable_Header = Variable_Header
    def factory(*args_, **kwargs_):
        if EarthExplorerHeaderType.subclass:
            return EarthExplorerHeaderType.subclass(*args_, **kwargs_)
        else:
            return EarthExplorerHeaderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Fixed_Header(self): return self.Fixed_Header
    def set_Fixed_Header(self, Fixed_Header): self.Fixed_Header = Fixed_Header
    def get_Variable_Header(self): return self.Variable_Header
    def set_Variable_Header(self, Variable_Header): self.Variable_Header = Variable_Header
    def hasContent_(self):
        if (
            self.Fixed_Header is not None or
            self.Variable_Header is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EarthExplorerHeaderType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EarthExplorerHeaderType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EarthExplorerHeaderType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EarthExplorerHeaderType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Fixed_Header is not None:
            self.Fixed_Header.export(outfile, level, namespace_, name_='Fixed_Header', pretty_print=pretty_print)
        if self.Variable_Header is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVariable_Header>%s</%sVariable_Header>%s' % (namespace_, self.gds_format_string(quote_xml(self.Variable_Header).encode(ExternalEncoding), input_name='Variable_Header'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='EarthExplorerHeaderType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Fixed_Header is not None:
            showIndent(outfile, level)
            outfile.write('Fixed_Header=model_.Fixed_HeaderType(\n')
            self.Fixed_Header.exportLiteral(outfile, level, name_='Fixed_Header')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Variable_Header is not None:
            showIndent(outfile, level)
            outfile.write('Variable_Header=%s,\n' % quote_python(self.Variable_Header).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Fixed_Header':
            obj_ = Fixed_HeaderType.factory()
            obj_.build(child_)
            self.Fixed_Header = obj_
        elif nodeName_ == 'Variable_Header':
            Variable_Header_ = child_.text
            Variable_Header_ = self.gds_validate_string(Variable_Header_, node, 'Variable_Header')
            self.Variable_Header = Variable_Header_
# end class EarthExplorerHeaderType


class Variable_Header(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Variable_Header.subclass:
            return Variable_Header.subclass(*args_, **kwargs_)
        else:
            return Variable_Header(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Variable_Header', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Variable_Header')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Variable_Header'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Variable_Header', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Variable_Header'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Variable_Header


class EarthExplorerDataBlockType(GeneratedsSuper):
    """EOFFS datablock type"""
    subclass = None
    superclass = None
    def __init__(self, type_=None, report=None):
        self.type_ = _cast(None, type_)
        self.report = report
    def factory(*args_, **kwargs_):
        if EarthExplorerDataBlockType.subclass:
            return EarthExplorerDataBlockType.subclass(*args_, **kwargs_)
        else:
            return EarthExplorerDataBlockType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_report(self): return self.report
    def set_report(self, report): self.report = report
    def get_type(self): return self.type_
    def set_type(self, type_): self.type_ = type_
    def hasContent_(self):
        if (
            self.report is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EarthExplorerDataBlockType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EarthExplorerDataBlockType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EarthExplorerDataBlockType'):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            outfile.write(' type=%s' % (self.gds_format_string(quote_attrib(self.type_).encode(ExternalEncoding), input_name='type'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='EarthExplorerDataBlockType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.report is not None:
            self.report.export(outfile, level, namespace_, name_='report', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EarthExplorerDataBlockType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.type_ is not None and 'type_' not in already_processed:
            already_processed.add('type_')
            showIndent(outfile, level)
            outfile.write('type_="%s",\n' % (self.type_,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.report is not None:
            showIndent(outfile, level)
            outfile.write('report=model_.report(\n')
            self.report.exportLiteral(outfile, level)
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('type', node)
        if value is not None and 'type' not in already_processed:
            already_processed.add('type')
            self.type_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'report':
            obj_ = ReportType.factory()
            obj_.build(child_)
            self.report = obj_
# end class EarthExplorerDataBlockType


class InspectionType(GeneratedsSuper):
    """When the inspection has been created.Elapsed time for this
    inspection.When this inspection processing started.The uniq
    identifier for this inspection. For sentinel-2 product. This
    identifier is prefixed with the S2 namespace. (i.e.
    "http://www.esa.int/s2#ispCategory")The item on which this
    inspection is attached. This item is not necessary the same as
    the one specified on the top level checklist definition. It can
    be a sub item of the product.The URL pointing to the inspected
    itemHuman readable name of this inspection.Priority level of
    this inspectionThe status of the inspection processing. Possible
    status in this report are "Done" when inspection performed, or
    "Canceled" if inspection process was cancelled.Inspection result
    status : "PASSED" if the inspection successully processed,
    "FAILED" if the inspection does not reach expected values or
    "ERROR" if the inspector raise an error."""
    subclass = None
    superclass = None
    def __init__(self, status=None, name=None, processingStatus=None, creation=None, itemURL=None, priority=None, item=None, duration=None, execution=None, id=None):
        self.status = _cast(None, status)
        self.name = _cast(None, name)
        self.processingStatus = _cast(None, processingStatus)
        if isinstance(creation, basestring):
            initvalue_ = datetime_.datetime.strptime(creation, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = creation
        self.creation = initvalue_
        self.itemURL = _cast(None, itemURL)
        self.priority = _cast(int, priority)
        self.item = _cast(None, item)
        self.duration = _cast(float, duration)
        if isinstance(execution, basestring):
            initvalue_ = datetime_.datetime.strptime(execution, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = execution
        self.execution = initvalue_
        self.id = _cast(None, id)
        pass
    def factory(*args_, **kwargs_):
        if InspectionType.subclass:
            return InspectionType.subclass(*args_, **kwargs_)
        else:
            return InspectionType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_status(self): return self.status
    def set_status(self, status): self.status = status
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_processingStatus(self): return self.processingStatus
    def set_processingStatus(self, processingStatus): self.processingStatus = processingStatus
    def get_creation(self): return self.creation
    def set_creation(self, creation): self.creation = creation
    def get_itemURL(self): return self.itemURL
    def set_itemURL(self, itemURL): self.itemURL = itemURL
    def get_priority(self): return self.priority
    def set_priority(self, priority): self.priority = priority
    def get_item(self): return self.item
    def set_item(self, item): self.item = item
    def get_duration(self): return self.duration
    def set_duration(self, duration): self.duration = duration
    def get_execution(self): return self.execution
    def set_execution(self, execution): self.execution = execution
    def get_id(self): return self.id
    def set_id(self, id): self.id = id
    def validate_PassFailType(self, value):
        # Validate type PassFailType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='InspectionType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='InspectionType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='InspectionType'):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            outfile.write(' status=%s' % (quote_attrib(self.status), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.processingStatus is not None and 'processingStatus' not in already_processed:
            already_processed.add('processingStatus')
            outfile.write(' processingStatus=%s' % (self.gds_format_string(quote_attrib(self.processingStatus).encode(ExternalEncoding), input_name='processingStatus'), ))
        if self.creation is not None and 'creation' not in already_processed:
            already_processed.add('creation')
            outfile.write(' creation="%s"' % self.gds_format_datetime(self.creation, input_name='creation'))
        if self.itemURL is not None and 'itemURL' not in already_processed:
            already_processed.add('itemURL')
            outfile.write(' itemURL=%s' % (self.gds_format_string(quote_attrib(self.itemURL).encode(ExternalEncoding), input_name='itemURL'), ))
        if self.priority is not None and 'priority' not in already_processed:
            already_processed.add('priority')
            outfile.write(' priority="%s"' % self.gds_format_integer(self.priority, input_name='priority'))
        if self.item is not None and 'item' not in already_processed:
            already_processed.add('item')
            outfile.write(' item=%s' % (self.gds_format_string(quote_attrib(self.item).encode(ExternalEncoding), input_name='item'), ))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            outfile.write(' duration="%s"' % self.gds_format_float(self.duration, input_name='duration'))
        if self.execution is not None and 'execution' not in already_processed:
            already_processed.add('execution')
            outfile.write(' execution="%s"' % self.gds_format_datetime(self.execution, input_name='execution'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            outfile.write(' id=%s' % (self.gds_format_string(quote_attrib(self.id).encode(ExternalEncoding), input_name='id'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='InspectionType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='InspectionType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.status is not None and 'status' not in already_processed:
            already_processed.add('status')
            showIndent(outfile, level)
            outfile.write('status="%s",\n' % (self.status,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.processingStatus is not None and 'processingStatus' not in already_processed:
            already_processed.add('processingStatus')
            showIndent(outfile, level)
            outfile.write('processingStatus="%s",\n' % (self.processingStatus,))
        if self.creation is not None and 'creation' not in already_processed:
            already_processed.add('creation')
            showIndent(outfile, level)
            outfile.write('creation=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.creation, input_name='creation'))
        if self.itemURL is not None and 'itemURL' not in already_processed:
            already_processed.add('itemURL')
            showIndent(outfile, level)
            outfile.write('itemURL="%s",\n' % (self.itemURL,))
        if self.priority is not None and 'priority' not in already_processed:
            already_processed.add('priority')
            showIndent(outfile, level)
            outfile.write('priority=%d,\n' % (self.priority,))
        if self.item is not None and 'item' not in already_processed:
            already_processed.add('item')
            showIndent(outfile, level)
            outfile.write('item="%s",\n' % (self.item,))
        if self.duration is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            showIndent(outfile, level)
            outfile.write('duration=%f,\n' % (self.duration,))
        if self.execution is not None and 'execution' not in already_processed:
            already_processed.add('execution')
            showIndent(outfile, level)
            outfile.write('execution=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.execution, input_name='execution'))
        if self.id is not None and 'id' not in already_processed:
            already_processed.add('id')
            showIndent(outfile, level)
            outfile.write('id="%s",\n' % (self.id,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('status', node)
        if value is not None and 'status' not in already_processed:
            already_processed.add('status')
            self.status = value
            self.validate_PassFailType(self.status)    # validate type PassFailType
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('processingStatus', node)
        if value is not None and 'processingStatus' not in already_processed:
            already_processed.add('processingStatus')
            self.processingStatus = value
        value = find_attr_value_('creation', node)
        if value is not None and 'creation' not in already_processed:
            already_processed.add('creation')
            try:
                self.creation = self.gds_parse_datetime(value)
            except ValueError, exp:
                raise ValueError('Bad date-time attribute (creation): %s' % exp)
        value = find_attr_value_('itemURL', node)
        if value is not None and 'itemURL' not in already_processed:
            already_processed.add('itemURL')
            self.itemURL = value
        value = find_attr_value_('priority', node)
        if value is not None and 'priority' not in already_processed:
            already_processed.add('priority')
            try:
                self.priority = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
        value = find_attr_value_('item', node)
        if value is not None and 'item' not in already_processed:
            already_processed.add('item')
            self.item = value
        value = find_attr_value_('duration', node)
        if value is not None and 'duration' not in already_processed:
            already_processed.add('duration')
            try:
                self.duration = float(value)
            except ValueError, exp:
                raise ValueError('Bad float/double attribute (duration): %s' % exp)
        value = find_attr_value_('execution', node)
        if value is not None and 'execution' not in already_processed:
            already_processed.add('execution')
            try:
                self.execution = self.gds_parse_datetime(value)
            except ValueError, exp:
                raise ValueError('Bad date-time attribute (execution): %s' % exp)
        value = find_attr_value_('id', node)
        if value is not None and 'id' not in already_processed:
            already_processed.add('id')
            self.id = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class InspectionType


class ItemType(GeneratedsSuper):
    """the url to the itemThe human readable class name of this item.the
    human readable name of this item.Drb class"""
    subclass = None
    superclass = None
    def __init__(self, url=None, className=None, name=None, class_=None):
        self.url = _cast(None, url)
        self.className = _cast(None, className)
        self.name = _cast(None, name)
        self.class_ = _cast(None, class_)
        pass
    def factory(*args_, **kwargs_):
        if ItemType.subclass:
            return ItemType.subclass(*args_, **kwargs_)
        else:
            return ItemType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_url(self): return self.url
    def set_url(self, url): self.url = url
    def get_className(self): return self.className
    def set_className(self, className): self.className = className
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_class(self): return self.class_
    def set_class(self, class_): self.class_ = class_
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ItemType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ItemType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ItemType'):
        if self.url is not None and 'url' not in already_processed:
            already_processed.add('url')
            outfile.write(' url=%s' % (self.gds_format_string(quote_attrib(self.url).encode(ExternalEncoding), input_name='url'), ))
        if self.className is not None and 'className' not in already_processed:
            already_processed.add('className')
            outfile.write(' className=%s' % (self.gds_format_string(quote_attrib(self.className).encode(ExternalEncoding), input_name='className'), ))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            outfile.write(' class=%s' % (self.gds_format_string(quote_attrib(self.class_).encode(ExternalEncoding), input_name='class'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ItemType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='ItemType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.url is not None and 'url' not in already_processed:
            already_processed.add('url')
            showIndent(outfile, level)
            outfile.write('url="%s",\n' % (self.url,))
        if self.className is not None and 'className' not in already_processed:
            already_processed.add('className')
            showIndent(outfile, level)
            outfile.write('className="%s",\n' % (self.className,))
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
        if self.class_ is not None and 'class_' not in already_processed:
            already_processed.add('class_')
            showIndent(outfile, level)
            outfile.write('class_="%s",\n' % (self.class_,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('url', node)
        if value is not None and 'url' not in already_processed:
            already_processed.add('url')
            self.url = value
        value = find_attr_value_('className', node)
        if value is not None and 'className' not in already_processed:
            already_processed.add('className')
            self.className = value
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
        value = find_attr_value_('class', node)
        if value is not None and 'class' not in already_processed:
            already_processed.add('class')
            self.class_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class ItemType


class CheckListType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, parentID=None, name=None, version=None, item=None, check=None):
        self.parentID = parentID
        self.name = name
        self.version = version
        self.item = item
        self.check = check
    def factory(*args_, **kwargs_):
        if CheckListType.subclass:
            return CheckListType.subclass(*args_, **kwargs_)
        else:
            return CheckListType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_parentID(self): return self.parentID
    def set_parentID(self, parentID): self.parentID = parentID
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_version(self): return self.version
    def set_version(self, version): self.version = version
    def get_item(self): return self.item
    def set_item(self, item): self.item = item
    def get_check(self): return self.check
    def set_check(self, check): self.check = check
    def hasContent_(self):
        if (
            self.parentID is not None or
            self.name is not None or
            self.version is not None or
            self.item is not None or
            self.check is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CheckListType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CheckListType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CheckListType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CheckListType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.parentID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sparentID>%s</%sparentID>%s' % (namespace_, self.gds_format_string(quote_xml(self.parentID).encode(ExternalEncoding), input_name='parentID'), namespace_, eol_))
        if self.name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sname>%s</%sname>%s' % (namespace_, self.gds_format_string(quote_xml(self.name).encode(ExternalEncoding), input_name='name'), namespace_, eol_))
        if self.version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sversion>%s</%sversion>%s' % (namespace_, self.gds_format_string(quote_xml(self.version).encode(ExternalEncoding), input_name='version'), namespace_, eol_))
        if self.item is not None:
            self.item.export(outfile, level, namespace_, name_='item', pretty_print=pretty_print)
        if self.check is not None:
            self.check.export(outfile, level, namespace_, name_='check', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CheckListType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.parentID is not None:
            showIndent(outfile, level)
            outfile.write('parentID=%s,\n' % quote_python(self.parentID).encode(ExternalEncoding))
        if self.name is not None:
            showIndent(outfile, level)
            outfile.write('name=%s,\n' % quote_python(self.name).encode(ExternalEncoding))
        if self.version is not None:
            showIndent(outfile, level)
            outfile.write('version=%s,\n' % quote_python(self.version).encode(ExternalEncoding))
        if self.item is not None:
            showIndent(outfile, level)
            outfile.write('item=model_.ItemType(\n')
            self.item.exportLiteral(outfile, level, name_='item')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.check is not None:
            showIndent(outfile, level)
            outfile.write('check=model_.checkType(\n')
            self.check.exportLiteral(outfile, level, name_='check')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'parentID':
            parentID_ = child_.text
            parentID_ = self.gds_validate_string(parentID_, node, 'parentID')
            self.parentID = parentID_
        elif nodeName_ == 'name':
            name_ = child_.text
            name_ = self.gds_validate_string(name_, node, 'name')
            self.name = name_
        elif nodeName_ == 'version':
            version_ = child_.text
            version_ = self.gds_validate_string(version_, node, 'version')
            self.version = version_
        elif nodeName_ == 'item':
            obj_ = ItemType.factory()
            obj_.build(child_)
            self.item = obj_
        elif nodeName_ == 'check':
            obj_ = checkType.factory()
            obj_.build(child_)
            self.check = obj_
# end class CheckListType


class ReportType(GeneratedsSuper):
    """The version of the GIPP used to produce this report.The global
    status of the instections gathered into this report.The date of
    creation of this report."""
    subclass = None
    superclass = None
    def __init__(self, date=None, gippVersion=None, globalStatus=None, checkList=None):
        if isinstance(date, basestring):
            initvalue_ = datetime_.datetime.strptime(date, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = date
        self.date = initvalue_
        self.gippVersion = _cast(None, gippVersion)
        self.globalStatus = _cast(None, globalStatus)
        self.checkList = checkList
    def factory(*args_, **kwargs_):
        if ReportType.subclass:
            return ReportType.subclass(*args_, **kwargs_)
        else:
            return ReportType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_checkList(self): return self.checkList
    def set_checkList(self, checkList): self.checkList = checkList
    def get_date(self): return self.date
    def set_date(self, date): self.date = date
    def get_gippVersion(self): return self.gippVersion
    def set_gippVersion(self, gippVersion): self.gippVersion = gippVersion
    def get_globalStatus(self): return self.globalStatus
    def set_globalStatus(self, globalStatus): self.globalStatus = globalStatus
    def validate_PassFailType(self, value):
        # Validate type PassFailType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.checkList is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReportType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReportType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReportType'):
        if self.date is not None and 'date' not in already_processed:
            already_processed.add('date')
            outfile.write(' date="%s"' % self.gds_format_datetime(self.date, input_name='date'))
        if self.gippVersion is not None and 'gippVersion' not in already_processed:
            already_processed.add('gippVersion')
            outfile.write(' gippVersion=%s' % (self.gds_format_string(quote_attrib(self.gippVersion).encode(ExternalEncoding), input_name='gippVersion'), ))
        if self.globalStatus is not None and 'globalStatus' not in already_processed:
            already_processed.add('globalStatus')
            outfile.write(' globalStatus=%s' % (quote_attrib(self.globalStatus), ))
    def exportChildren(self, outfile, level, namespace_='', name_='ReportType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.checkList is not None:
            self.checkList.export(outfile, level, namespace_, name_='checkList', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReportType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.date is not None and 'date' not in already_processed:
            already_processed.add('date')
            showIndent(outfile, level)
            outfile.write('date=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.date, input_name='date'))
        if self.gippVersion is not None and 'gippVersion' not in already_processed:
            already_processed.add('gippVersion')
            showIndent(outfile, level)
            outfile.write('gippVersion="%s",\n' % (self.gippVersion,))
        if self.globalStatus is not None and 'globalStatus' not in already_processed:
            already_processed.add('globalStatus')
            showIndent(outfile, level)
            outfile.write('globalStatus="%s",\n' % (self.globalStatus,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.checkList is not None:
            showIndent(outfile, level)
            outfile.write('checkList=model_.CheckListType(\n')
            self.checkList.exportLiteral(outfile, level, name_='checkList')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('date', node)
        if value is not None and 'date' not in already_processed:
            already_processed.add('date')
            try:
                self.date = self.gds_parse_datetime(value)
            except ValueError, exp:
                raise ValueError('Bad date-time attribute (date): %s' % exp)
        value = find_attr_value_('gippVersion', node)
        if value is not None and 'gippVersion' not in already_processed:
            already_processed.add('gippVersion')
            self.gippVersion = value
            self.gippVersion = ' '.join(self.gippVersion.split())
        value = find_attr_value_('globalStatus', node)
        if value is not None and 'globalStatus' not in already_processed:
            already_processed.add('globalStatus')
            self.globalStatus = value
            self.validate_PassFailType(self.globalStatus)    # validate type PassFailType
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'checkList':
            obj_ = CheckListType.factory()
            obj_.build(child_)
            self.checkList = obj_
# end class ReportType


class Fixed_HeaderType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, File_Name=None, File_Description=None, Notes=None, Mission=None, File_Class=None, File_Type=None, Validity_Period=None, File_Version=None, Source=None):
        self.File_Name = File_Name
        self.File_Description = File_Description
        self.Notes = Notes
        self.Mission = Mission
        self.File_Class = File_Class
        self.File_Type = File_Type
        self.Validity_Period = Validity_Period
        self.File_Version = File_Version
        self.Source = Source
    def factory(*args_, **kwargs_):
        if Fixed_HeaderType.subclass:
            return Fixed_HeaderType.subclass(*args_, **kwargs_)
        else:
            return Fixed_HeaderType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_File_Name(self): return self.File_Name
    def set_File_Name(self, File_Name): self.File_Name = File_Name
    def get_File_Description(self): return self.File_Description
    def set_File_Description(self, File_Description): self.File_Description = File_Description
    def get_Notes(self): return self.Notes
    def set_Notes(self, Notes): self.Notes = Notes
    def get_Mission(self): return self.Mission
    def set_Mission(self, Mission): self.Mission = Mission
    def get_File_Class(self): return self.File_Class
    def set_File_Class(self, File_Class): self.File_Class = File_Class
    def get_File_Type(self): return self.File_Type
    def set_File_Type(self, File_Type): self.File_Type = File_Type
    def get_Validity_Period(self): return self.Validity_Period
    def set_Validity_Period(self, Validity_Period): self.Validity_Period = Validity_Period
    def get_File_Version(self): return self.File_Version
    def set_File_Version(self, File_Version): self.File_Version = File_Version
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def hasContent_(self):
        if (
            self.File_Name is not None or
            self.File_Description is not None or
            self.Notes is not None or
            self.Mission is not None or
            self.File_Class is not None or
            self.File_Type is not None or
            self.Validity_Period is not None or
            self.File_Version is not None or
            self.Source is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Fixed_HeaderType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Fixed_HeaderType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Fixed_HeaderType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Fixed_HeaderType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.File_Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFile_Name>%s</%sFile_Name>%s' % (namespace_, self.gds_format_string(quote_xml(self.File_Name).encode(ExternalEncoding), input_name='File_Name'), namespace_, eol_))
        if self.File_Description is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFile_Description>%s</%sFile_Description>%s' % (namespace_, self.gds_format_string(quote_xml(self.File_Description).encode(ExternalEncoding), input_name='File_Description'), namespace_, eol_))
        if self.Notes is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNotes>%s</%sNotes>%s' % (namespace_, self.gds_format_string(quote_xml(self.Notes).encode(ExternalEncoding), input_name='Notes'), namespace_, eol_))
        if self.Mission is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sMission>%s</%sMission>%s' % (namespace_, self.gds_format_string(quote_xml(self.Mission).encode(ExternalEncoding), input_name='Mission'), namespace_, eol_))
        if self.File_Class is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFile_Class>%s</%sFile_Class>%s' % (namespace_, self.gds_format_string(quote_xml(self.File_Class).encode(ExternalEncoding), input_name='File_Class'), namespace_, eol_))
        if self.File_Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFile_Type>%s</%sFile_Type>%s' % (namespace_, self.gds_format_string(quote_xml(self.File_Type).encode(ExternalEncoding), input_name='File_Type'), namespace_, eol_))
        if self.Validity_Period is not None:
            self.Validity_Period.export(outfile, level, namespace_, name_='Validity_Period', pretty_print=pretty_print)
        if self.File_Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFile_Version>%s</%sFile_Version>%s' % (namespace_, self.gds_format_integer(self.File_Version, input_name='File_Version'), namespace_, eol_))
        if self.Source is not None:
            self.Source.export(outfile, level, namespace_, name_='Source', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Fixed_HeaderType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.File_Name is not None:
            showIndent(outfile, level)
            outfile.write('File_Name=%s,\n' % quote_python(self.File_Name).encode(ExternalEncoding))
        if self.File_Description is not None:
            showIndent(outfile, level)
            outfile.write('File_Description=%s,\n' % quote_python(self.File_Description).encode(ExternalEncoding))
        if self.Notes is not None:
            showIndent(outfile, level)
            outfile.write('Notes=%s,\n' % quote_python(self.Notes).encode(ExternalEncoding))
        if self.Mission is not None:
            showIndent(outfile, level)
            outfile.write('Mission=%s,\n' % quote_python(self.Mission).encode(ExternalEncoding))
        if self.File_Class is not None:
            showIndent(outfile, level)
            outfile.write('File_Class=%s,\n' % quote_python(self.File_Class).encode(ExternalEncoding))
        if self.File_Type is not None:
            showIndent(outfile, level)
            outfile.write('File_Type=%s,\n' % quote_python(self.File_Type).encode(ExternalEncoding))
        if self.Validity_Period is not None:
            showIndent(outfile, level)
            outfile.write('Validity_Period=model_.Validity_PeriodType(\n')
            self.Validity_Period.exportLiteral(outfile, level, name_='Validity_Period')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.File_Version is not None:
            showIndent(outfile, level)
            outfile.write('File_Version=%d,\n' % self.File_Version)
        if self.Source is not None:
            showIndent(outfile, level)
            outfile.write('Source=model_.SourceType(\n')
            self.Source.exportLiteral(outfile, level, name_='Source')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'File_Name':
            File_Name_ = child_.text
            File_Name_ = self.gds_validate_string(File_Name_, node, 'File_Name')
            self.File_Name = File_Name_
        elif nodeName_ == 'File_Description':
            File_Description_ = child_.text
            File_Description_ = self.gds_validate_string(File_Description_, node, 'File_Description')
            self.File_Description = File_Description_
        elif nodeName_ == 'Notes':
            Notes_ = child_.text
            Notes_ = self.gds_validate_string(Notes_, node, 'Notes')
            self.Notes = Notes_
        elif nodeName_ == 'Mission':
            Mission_ = child_.text
            Mission_ = self.gds_validate_string(Mission_, node, 'Mission')
            self.Mission = Mission_
        elif nodeName_ == 'File_Class':
            File_Class_ = child_.text
            File_Class_ = self.gds_validate_string(File_Class_, node, 'File_Class')
            self.File_Class = File_Class_
        elif nodeName_ == 'File_Type':
            File_Type_ = child_.text
            File_Type_ = self.gds_validate_string(File_Type_, node, 'File_Type')
            self.File_Type = File_Type_
        elif nodeName_ == 'Validity_Period':
            obj_ = Validity_PeriodType.factory()
            obj_.build(child_)
            self.Validity_Period = obj_
        elif nodeName_ == 'File_Version':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ <= 0:
                raise_parse_error(child_, 'requires positiveInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'File_Version')
            self.File_Version = ival_
        elif nodeName_ == 'Source':
            obj_ = SourceType.factory()
            obj_.build(child_)
            self.Source = obj_
# end class Fixed_HeaderType


class Mission(GeneratedsSuper):
    """Fixed string : Mission ID extracted from filename (MMM =
    "S2_"|"S2A"|"S2B")"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Mission.subclass:
            return Mission.subclass(*args_, **kwargs_)
        else:
            return Mission(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Mission', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Mission')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Mission'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Mission', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Mission'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Mission


class File_Type(GeneratedsSuper):
    """File type extracted from filename "TTTTTTTTTT" = FFFFDDDDDD
    whereFile Category : "FFF" = "REP_" Semantic Descriptor :
    "DDDDDD" = "OLQCPA" (See PSD-V05)"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if File_Type.subclass:
            return File_Type.subclass(*args_, **kwargs_)
        else:
            return File_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='File_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='File_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='File_Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='File_Type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='File_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class File_Type


class File_Version(GeneratedsSuper):
    """must be the same as ../../../Data_Block/report/@version"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if File_Version.subclass:
            return File_Version.subclass(*args_, **kwargs_)
        else:
            return File_Version(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='File_Version', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='File_Version')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='File_Version'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='File_Version', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='File_Version'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class File_Version


class Validity_PeriodType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, Validity_Start=None, Validity_Stop=None):
        self.Validity_Start = Validity_Start
        self.Validity_Stop = Validity_Stop
    def factory(*args_, **kwargs_):
        if Validity_PeriodType.subclass:
            return Validity_PeriodType.subclass(*args_, **kwargs_)
        else:
            return Validity_PeriodType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Validity_Start(self): return self.Validity_Start
    def set_Validity_Start(self, Validity_Start): self.Validity_Start = Validity_Start
    def get_Validity_Stop(self): return self.Validity_Stop
    def set_Validity_Stop(self, Validity_Stop): self.Validity_Stop = Validity_Stop
    def validate_CcsdsDateType(self, value):
        # Validate type CcsdsDateType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.Validity_Start is not None or
            self.Validity_Stop is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Validity_PeriodType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Validity_PeriodType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Validity_PeriodType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Validity_PeriodType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Validity_Start is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValidity_Start>%s</%sValidity_Start>%s' % (namespace_, self.gds_format_string(quote_xml(self.Validity_Start).encode(ExternalEncoding), input_name='Validity_Start'), namespace_, eol_))
        if self.Validity_Stop is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValidity_Stop>%s</%sValidity_Stop>%s' % (namespace_, self.gds_format_string(quote_xml(self.Validity_Stop).encode(ExternalEncoding), input_name='Validity_Stop'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='Validity_PeriodType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.Validity_Start is not None:
            showIndent(outfile, level)
            outfile.write('Validity_Start=%s,\n' % quote_python(self.Validity_Start).encode(ExternalEncoding))
        if self.Validity_Stop is not None:
            showIndent(outfile, level)
            outfile.write('Validity_Stop=%s,\n' % quote_python(self.Validity_Stop).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Validity_Start':
            Validity_Start_ = child_.text
            Validity_Start_ = self.gds_validate_string(Validity_Start_, node, 'Validity_Start')
            self.Validity_Start = Validity_Start_
            self.validate_CcsdsDateType(self.Validity_Start)    # validate type CcsdsDateType
        elif nodeName_ == 'Validity_Stop':
            Validity_Stop_ = child_.text
            Validity_Stop_ = self.gds_validate_string(Validity_Stop_, node, 'Validity_Stop')
            self.Validity_Stop = Validity_Stop_
            self.validate_CcsdsDateType(self.Validity_Stop)    # validate type CcsdsDateType
# end class Validity_PeriodType


class SourceType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, System=None, Creator=None, Creator_Version=None, Creation_Date=None):
        self.System = System
        self.Creator = Creator
        self.Creator_Version = Creator_Version
        self.Creation_Date = Creation_Date
    def factory(*args_, **kwargs_):
        if SourceType.subclass:
            return SourceType.subclass(*args_, **kwargs_)
        else:
            return SourceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_System(self): return self.System
    def set_System(self, System): self.System = System
    def get_Creator(self): return self.Creator
    def set_Creator(self, Creator): self.Creator = Creator
    def get_Creator_Version(self): return self.Creator_Version
    def set_Creator_Version(self, Creator_Version): self.Creator_Version = Creator_Version
    def get_Creation_Date(self): return self.Creation_Date
    def set_Creation_Date(self, Creation_Date): self.Creation_Date = Creation_Date
    def validate_CcsdsDateType(self, value):
        # Validate type CcsdsDateType, a restriction on xs:string.
        pass
    def hasContent_(self):
        if (
            self.System is not None or
            self.Creator is not None or
            self.Creator_Version is not None or
            self.Creation_Date is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SourceType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SourceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SourceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SourceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.System is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSystem>%s</%sSystem>%s' % (namespace_, self.gds_format_string(quote_xml(self.System).encode(ExternalEncoding), input_name='System'), namespace_, eol_))
        if self.Creator is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCreator>%s</%sCreator>%s' % (namespace_, self.gds_format_string(quote_xml(self.Creator).encode(ExternalEncoding), input_name='Creator'), namespace_, eol_))
        if self.Creator_Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCreator_Version>%s</%sCreator_Version>%s' % (namespace_, self.gds_format_string(quote_xml(self.Creator_Version).encode(ExternalEncoding), input_name='Creator_Version'), namespace_, eol_))
        if self.Creation_Date is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCreation_Date>%s</%sCreation_Date>%s' % (namespace_, self.gds_format_string(quote_xml(self.Creation_Date).encode(ExternalEncoding), input_name='Creation_Date'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='SourceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.System is not None:
            showIndent(outfile, level)
            outfile.write('System=%s,\n' % quote_python(self.System).encode(ExternalEncoding))
        if self.Creator is not None:
            showIndent(outfile, level)
            outfile.write('Creator=%s,\n' % quote_python(self.Creator).encode(ExternalEncoding))
        if self.Creator_Version is not None:
            showIndent(outfile, level)
            outfile.write('Creator_Version=%s,\n' % quote_python(self.Creator_Version).encode(ExternalEncoding))
        if self.Creation_Date is not None:
            showIndent(outfile, level)
            outfile.write('Creation_Date=%s,\n' % quote_python(self.Creation_Date).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'System':
            System_ = child_.text
            System_ = self.gds_validate_string(System_, node, 'System')
            self.System = System_
        elif nodeName_ == 'Creator':
            Creator_ = child_.text
            Creator_ = self.gds_validate_string(Creator_, node, 'Creator')
            self.Creator = Creator_
        elif nodeName_ == 'Creator_Version':
            Creator_Version_ = child_.text
            Creator_Version_ = self.gds_validate_string(Creator_Version_, node, 'Creator_Version')
            self.Creator_Version = Creator_Version_
        elif nodeName_ == 'Creation_Date':
            Creation_Date_ = child_.text
            Creation_Date_ = self.gds_validate_string(Creation_Date_, node, 'Creation_Date')
            self.Creation_Date = Creation_Date_
            self.validate_CcsdsDateType(self.Creation_Date)    # validate type CcsdsDateType
# end class SourceType


class checkType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, inspection=None, message=None, extraValues=None):
        self.inspection = inspection
        self.message = message
        self.extraValues = extraValues
    def factory(*args_, **kwargs_):
        if checkType.subclass:
            return checkType.subclass(*args_, **kwargs_)
        else:
            return checkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_inspection(self): return self.inspection
    def set_inspection(self, inspection): self.inspection = inspection
    def get_message(self): return self.message
    def set_message(self, message): self.message = message
    def get_extraValues(self): return self.extraValues
    def set_extraValues(self, extraValues): self.extraValues = extraValues
    def hasContent_(self):
        if (
            self.inspection is not None or
            self.message is not None or
            self.extraValues is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='checkType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='checkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='checkType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='checkType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.inspection is not None:
            self.inspection.export(outfile, level, namespace_, name_='inspection', pretty_print=pretty_print)
        if self.message is not None:
            self.message.export(outfile, level, namespace_, name_='message', pretty_print=pretty_print)
        if self.extraValues is not None:
            self.extraValues.export(outfile, level, namespace_, name_='extraValues', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='checkType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.inspection is not None:
            showIndent(outfile, level)
            outfile.write('inspection=model_.InspectionType(\n')
            self.inspection.exportLiteral(outfile, level, name_='inspection')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.message is not None:
            showIndent(outfile, level)
            outfile.write('message=model_.messageType(\n')
            self.message.exportLiteral(outfile, level, name_='message')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.extraValues is not None:
            showIndent(outfile, level)
            outfile.write('extraValues=model_.extraValuesType(\n')
            self.extraValues.exportLiteral(outfile, level, name_='extraValues')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'inspection':
            obj_ = InspectionType.factory()
            obj_.build(child_)
            self.inspection = obj_
        elif nodeName_ == 'message':
            obj_ = messageType.factory()
            obj_.build(child_)
            self.message = obj_
        elif nodeName_ == 'extraValues':
            obj_ = extraValuesType.factory()
            obj_.build(child_)
            self.extraValues = obj_
# end class checkType


class messageType(GeneratedsSuper):
    """The content type of the message. Usually content type is set to
    'text/plain"."""
    subclass = None
    superclass = None
    def __init__(self, contentType=None, valueOf_=None):
        self.contentType = _cast(None, contentType)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if messageType.subclass:
            return messageType.subclass(*args_, **kwargs_)
        else:
            return messageType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_contentType(self): return self.contentType
    def set_contentType(self, contentType): self.contentType = contentType
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='messageType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='messageType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='messageType'):
        if self.contentType is not None and 'contentType' not in already_processed:
            already_processed.add('contentType')
            outfile.write(' contentType=%s' % (self.gds_format_string(quote_attrib(self.contentType).encode(ExternalEncoding), input_name='contentType'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='messageType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='messageType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.contentType is not None and 'contentType' not in already_processed:
            already_processed.add('contentType')
            showIndent(outfile, level)
            outfile.write('contentType="%s",\n' % (self.contentType,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('contentType', node)
        if value is not None and 'contentType' not in already_processed:
            already_processed.add('contentType')
            self.contentType = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class messageType


class extraValuesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, value=None):
        if value is None:
            self.value = []
        else:
            self.value = value
    def factory(*args_, **kwargs_):
        if extraValuesType.subclass:
            return extraValuesType.subclass(*args_, **kwargs_)
        else:
            return extraValuesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_value(self): return self.value
    def set_value(self, value): self.value = value
    def add_value(self, value): self.value.append(value)
    def insert_value(self, index, value): self.value[index] = value
    def hasContent_(self):
        if (
            self.value
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='extraValuesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='extraValuesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='extraValuesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='extraValuesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for value_ in self.value:
            value_.export(outfile, level, namespace_, name_='value', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='extraValuesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('value=[\n')
        level += 1
        for value_ in self.value:
            showIndent(outfile, level)
            outfile.write('model_.valueType(\n')
            value_.exportLiteral(outfile, level, name_='valueType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'value':
            obj_ = valueType.factory()
            obj_.build(child_)
            self.value.append(obj_)
# end class extraValuesType


class valueType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, name=None, valueOf_=None):
        self.name = _cast(None, name)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if valueType.subclass:
            return valueType.subclass(*args_, **kwargs_)
        else:
            return valueType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_name(self): return self.name
    def set_name(self, name): self.name = name
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='valueType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='valueType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='valueType'):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            outfile.write(' name=%s' % (self.gds_format_string(quote_attrib(self.name).encode(ExternalEncoding), input_name='name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='valueType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='valueType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.name is not None and 'name' not in already_processed:
            already_processed.add('name')
            showIndent(outfile, level)
            outfile.write('name="%s",\n' % (self.name,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('name', node)
        if value is not None and 'name' not in already_processed:
            already_processed.add('name')
            self.name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class valueType


class Earth_Explorer_File(EarthExplorerFileType):
    """EOFFS entry point of this xml file"""
    subclass = None
    superclass = EarthExplorerFileType
    def __init__(self, Earth_Explorer_Header=None, Data_Block=None):
        super(Earth_Explorer_File, self).__init__()
        self.Earth_Explorer_Header = Earth_Explorer_Header
        self.Data_Block = Data_Block
    def factory(*args_, **kwargs_):
        if Earth_Explorer_File.subclass:
            return Earth_Explorer_File.subclass(*args_, **kwargs_)
        else:
            return Earth_Explorer_File(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Earth_Explorer_Header(self): return self.Earth_Explorer_Header
    def set_Earth_Explorer_Header(self, Earth_Explorer_Header): self.Earth_Explorer_Header = Earth_Explorer_Header
    def get_Data_Block(self): return self.Data_Block
    def set_Data_Block(self, Data_Block): self.Data_Block = Data_Block
    def hasContent_(self):
        if (
            self.Earth_Explorer_Header is not None or
            self.Data_Block is not None or
            super(Earth_Explorer_File, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Earth_Explorer_File', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Earth_Explorer_File')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Earth_Explorer_File'):
        super(Earth_Explorer_File, self).exportAttributes(outfile, level, already_processed, namespace_, name_='Earth_Explorer_File')
    def exportChildren(self, outfile, level, namespace_='', name_='Earth_Explorer_File', fromsubclass_=False, pretty_print=True):
        super(Earth_Explorer_File, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.Earth_Explorer_Header is not None:
            self.Earth_Explorer_Header.export(outfile, level, namespace_, name_='Earth_Explorer_Header', pretty_print=pretty_print)
        if self.Data_Block is not None:
            self.Data_Block.export(outfile, level, namespace_, name_='Data_Block', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Earth_Explorer_File'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(Earth_Explorer_File, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(Earth_Explorer_File, self).exportLiteralChildren(outfile, level, name_)
        if self.Earth_Explorer_Header is not None:
            showIndent(outfile, level)
            outfile.write('Earth_Explorer_Header=model_.EarthExplorerHeaderType(\n')
            self.Earth_Explorer_Header.exportLiteral(outfile, level, name_='Earth_Explorer_Header')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Data_Block is not None:
            showIndent(outfile, level)
            outfile.write('Data_Block=model_.EarthExplorerDataBlockType(\n')
            self.Data_Block.exportLiteral(outfile, level, name_='Data_Block')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        super(Earth_Explorer_File, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Earth_Explorer_Header':
            obj_ = EarthExplorerHeaderType.factory()
            obj_.build(child_)
            self.Earth_Explorer_Header = obj_
        elif nodeName_ == 'Data_Block':
            obj_ = EarthExplorerDataBlockType.factory()
            obj_.build(child_)
            self.Data_Block = obj_
        super(Earth_Explorer_File, self).buildChildren(child_, node, nodeName_, True)
# end class Earth_Explorer_File


GDSClassesMapping = {
    'Source': SourceType,
    'checkList': CheckListType,
    'Data_Block': EarthExplorerDataBlockType,
    'value': valueType,
    'Validity_Period': Validity_PeriodType,
    'item': ItemType,
    'report': ReportType,
    'extraValues': extraValuesType,
    'message': messageType,
    'Earth_Explorer_Header': EarthExplorerHeaderType,
    'inspection': InspectionType,
    'check': checkType,
    'Fixed_Header': Fixed_HeaderType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Earth_Explorer_File'
        rootClass = Earth_Explorer_File
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(
        sys.stdout, 0, name_=rootTag,
        namespacedef_='',
        pretty_print=True)
    return rootObj


def parseEtree(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Earth_Explorer_File'
        rootClass = Earth_Explorer_File
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    content = etree_.tostring(
        rootElement, pretty_print=True,
        xml_declaration=True, encoding="utf-8")
    sys.stdout.write(content)
    sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    roots = get_root_tag(rootNode)
    rootClass = roots[1]
    if rootClass is None:
        rootClass = Earth_Explorer_File
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(
        sys.stdout, 0, name_="Earth_Explorer_File",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Earth_Explorer_File'
        rootClass = Earth_Explorer_File
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from OLQC_Report import *\n\n')
    sys.stdout.write('import OLQC_Report as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "CheckListType",
    "EarthExplorerDataBlockType",
    "EarthExplorerFileType",
    "EarthExplorerHeaderType",
    "Earth_Explorer_File",
    "File_Type",
    "File_Version",
    "Fixed_HeaderType",
    "InspectionType",
    "ItemType",
    "Mission",
    "ReportType",
    "SourceType",
    "Validity_PeriodType",
    "Variable_Header",
    "checkType",
    "extraValuesType",
    "messageType",
    "valueType"
]
