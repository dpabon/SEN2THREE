#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Wed Oct 30 09:06:02 2013 by generateDS.py version 2.10b.
#

import sys
import getopt
import re as re_
import base64
import datetime as datetime_

etree_ = None
Verbose_import_ = False
(
    XMLParser_import_none, XMLParser_import_lxml,
    XMLParser_import_elementtree
) = range(3)
XMLParser_import_library = None
try:
    # lxml
    from lxml import etree as etree_
    XMLParser_import_library = XMLParser_import_lxml
    if Verbose_import_:
        print("running with lxml.etree")
except ImportError:
    try:
        # cElementTree from Python 2.5+
        import xml.etree.cElementTree as etree_
        XMLParser_import_library = XMLParser_import_elementtree
        if Verbose_import_:
            print("running with cElementTree on Python 2.5+")
    except ImportError:
        try:
            # ElementTree from Python 2.5+
            import xml.etree.ElementTree as etree_
            XMLParser_import_library = XMLParser_import_elementtree
            if Verbose_import_:
                print("running with ElementTree on Python 2.5+")
        except ImportError:
            try:
                # normal cElementTree install
                import cElementTree as etree_
                XMLParser_import_library = XMLParser_import_elementtree
                if Verbose_import_:
                    print("running with cElementTree")
            except ImportError:
                try:
                    # normal ElementTree install
                    import elementtree.ElementTree as etree_
                    XMLParser_import_library = XMLParser_import_elementtree
                    if Verbose_import_:
                        print("running with ElementTree")
                except ImportError:
                    raise ImportError(
                        "Failed to import ElementTree from any known place")


def parsexml_(*args, **kwargs):
    if (XMLParser_import_library == XMLParser_import_lxml and
            'parser' not in kwargs):
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        kwargs['parser'] = etree_.ETCompatXMLParser()
    doc = etree_.parse(*args, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError, exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node, input_name=''):
            return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_integer_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return input_data
        def gds_format_float(self, input_data, input_name=''):
            return '%f' % input_data
        def gds_validate_float(self, input_data, node, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_float_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return input_data
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_double_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return input_data
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % input_data
        def gds_validate_boolean_list(self, input_data, node, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return input_data
        def gds_validate_datetime(self, input_data, node, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'GMT')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'ascii'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    if XMLParser_import_library == XMLParser_import_lxml:
        msg = '%s (element %s/line %d)' % (
            msg, node.tag, node.sourceline, )
    else:
        msg = '%s (element %s)' % (msg, node.tag, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class Inventory_Metadata(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, File_ID=None, Parent_ID=None, Group_ID=None, File_Name=None, File_Version=None, System=None, Source=None, Source_Sw_Version=None, Generation_Time=None, Validity_Start=None, Validity_Stop=None, Start_Orbit_Number=None, Stop_Orbit_Number=None, Geographic_Localization=None, Quality_Info=None, Data_Size=None, File_Type=None, Detector=None, File_Class=None, Sensor_Code=None, Sensor_Mode=None, Acquisition_Station=None, Processing_Station=None, Satellite_Code=None, Ascending_Flag=None, CloudPercentage=None):
        self.File_ID = File_ID
        self.Parent_ID = Parent_ID
        self.Group_ID = Group_ID
        self.File_Name = File_Name
        self.File_Version = File_Version
        self.System = System
        self.Source = Source
        self.Source_Sw_Version = Source_Sw_Version
        self.Generation_Time = Generation_Time
        self.Validity_Start = Validity_Start
        self.Validity_Stop = Validity_Stop
        self.Start_Orbit_Number = Start_Orbit_Number
        self.Stop_Orbit_Number = Stop_Orbit_Number
        self.Geographic_Localization = Geographic_Localization
        self.Quality_Info = Quality_Info
        self.Data_Size = Data_Size
        self.File_Type = File_Type
        self.Detector = Detector
        self.File_Class = File_Class
        self.Sensor_Code = Sensor_Code
        self.Sensor_Mode = Sensor_Mode
        self.Acquisition_Station = Acquisition_Station
        self.Processing_Station = Processing_Station
        self.Satellite_Code = Satellite_Code
        self.Ascending_Flag = Ascending_Flag
        self.CloudPercentage = CloudPercentage
    def factory(*args_, **kwargs_):
        if Inventory_Metadata.subclass:
            return Inventory_Metadata.subclass(*args_, **kwargs_)
        else:
            return Inventory_Metadata(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_File_ID(self): return self.File_ID
    def set_File_ID(self, File_ID): self.File_ID = File_ID
    def get_Parent_ID(self): return self.Parent_ID
    def set_Parent_ID(self, Parent_ID): self.Parent_ID = Parent_ID
    def get_Group_ID(self): return self.Group_ID
    def set_Group_ID(self, Group_ID): self.Group_ID = Group_ID
    def get_File_Name(self): return self.File_Name
    def set_File_Name(self, File_Name): self.File_Name = File_Name
    def get_File_Version(self): return self.File_Version
    def set_File_Version(self, File_Version): self.File_Version = File_Version
    def get_System(self): return self.System
    def set_System(self, System): self.System = System
    def get_Source(self): return self.Source
    def set_Source(self, Source): self.Source = Source
    def get_Source_Sw_Version(self): return self.Source_Sw_Version
    def set_Source_Sw_Version(self, Source_Sw_Version): self.Source_Sw_Version = Source_Sw_Version
    def get_Generation_Time(self): return self.Generation_Time
    def set_Generation_Time(self, Generation_Time): self.Generation_Time = Generation_Time
    def get_Validity_Start(self): return self.Validity_Start
    def set_Validity_Start(self, Validity_Start): self.Validity_Start = Validity_Start
    def get_Validity_Stop(self): return self.Validity_Stop
    def set_Validity_Stop(self, Validity_Stop): self.Validity_Stop = Validity_Stop
    def get_Start_Orbit_Number(self): return self.Start_Orbit_Number
    def set_Start_Orbit_Number(self, Start_Orbit_Number): self.Start_Orbit_Number = Start_Orbit_Number
    def get_Stop_Orbit_Number(self): return self.Stop_Orbit_Number
    def set_Stop_Orbit_Number(self, Stop_Orbit_Number): self.Stop_Orbit_Number = Stop_Orbit_Number
    def get_Geographic_Localization(self): return self.Geographic_Localization
    def set_Geographic_Localization(self, Geographic_Localization): self.Geographic_Localization = Geographic_Localization
    def get_Quality_Info(self): return self.Quality_Info
    def set_Quality_Info(self, Quality_Info): self.Quality_Info = Quality_Info
    def get_Data_Size(self): return self.Data_Size
    def set_Data_Size(self, Data_Size): self.Data_Size = Data_Size
    def get_File_Type(self): return self.File_Type
    def set_File_Type(self, File_Type): self.File_Type = File_Type
    def get_Detector(self): return self.Detector
    def set_Detector(self, Detector): self.Detector = Detector
    def get_File_Class(self): return self.File_Class
    def set_File_Class(self, File_Class): self.File_Class = File_Class
    def get_Sensor_Code(self): return self.Sensor_Code
    def set_Sensor_Code(self, Sensor_Code): self.Sensor_Code = Sensor_Code
    def get_Sensor_Mode(self): return self.Sensor_Mode
    def set_Sensor_Mode(self, Sensor_Mode): self.Sensor_Mode = Sensor_Mode
    def get_Acquisition_Station(self): return self.Acquisition_Station
    def set_Acquisition_Station(self, Acquisition_Station): self.Acquisition_Station = Acquisition_Station
    def get_Processing_Station(self): return self.Processing_Station
    def set_Processing_Station(self, Processing_Station): self.Processing_Station = Processing_Station
    def get_Satellite_Code(self): return self.Satellite_Code
    def set_Satellite_Code(self, Satellite_Code): self.Satellite_Code = Satellite_Code
    def get_Ascending_Flag(self): return self.Ascending_Flag
    def set_Ascending_Flag(self, Ascending_Flag): self.Ascending_Flag = Ascending_Flag
    def get_CloudPercentage(self): return self.CloudPercentage
    def set_CloudPercentage(self, CloudPercentage): self.CloudPercentage = CloudPercentage
    def hasContent_(self):
        if (
            self.File_ID is not None or
            self.Parent_ID is not None or
            self.Group_ID is not None or
            self.File_Name is not None or
            self.File_Version is not None or
            self.System is not None or
            self.Source is not None or
            self.Source_Sw_Version is not None or
            self.Generation_Time is not None or
            self.Validity_Start is not None or
            self.Validity_Stop is not None or
            self.Start_Orbit_Number is not None or
            self.Stop_Orbit_Number is not None or
            self.Geographic_Localization is not None or
            self.Quality_Info is not None or
            self.Data_Size is not None or
            self.File_Type is not None or
            self.Detector is not None or
            self.File_Class is not None or
            self.Sensor_Code is not None or
            self.Sensor_Mode is not None or
            self.Acquisition_Station is not None or
            self.Processing_Station is not None or
            self.Satellite_Code is not None or
            self.Ascending_Flag is not None or
            self.CloudPercentage is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Inventory_Metadata', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Inventory_Metadata')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Inventory_Metadata'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Inventory_Metadata', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.File_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFile_ID>%s</%sFile_ID>%s' % (namespace_, self.gds_format_string(quote_xml(self.File_ID).encode(ExternalEncoding), input_name='File_ID'), namespace_, eol_))
        if self.Parent_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sParent_ID>%s</%sParent_ID>%s' % (namespace_, self.gds_format_string(quote_xml(self.Parent_ID).encode(ExternalEncoding), input_name='Parent_ID'), namespace_, eol_))
        if self.Group_ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGroup_ID>%s</%sGroup_ID>%s' % (namespace_, self.gds_format_string(quote_xml(self.Group_ID).encode(ExternalEncoding), input_name='Group_ID'), namespace_, eol_))
        if self.File_Name is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFile_Name>%s</%sFile_Name>%s' % (namespace_, self.gds_format_string(quote_xml(self.File_Name).encode(ExternalEncoding), input_name='File_Name'), namespace_, eol_))
        if self.File_Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFile_Version>%s</%sFile_Version>%s' % (namespace_, self.gds_format_string(quote_xml(self.File_Version).encode(ExternalEncoding), input_name='File_Version'), namespace_, eol_))
        if self.System is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSystem>%s</%sSystem>%s' % (namespace_, self.gds_format_string(quote_xml(self.System).encode(ExternalEncoding), input_name='System'), namespace_, eol_))
        if self.Source is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSource>%s</%sSource>%s' % (namespace_, self.gds_format_string(quote_xml(self.Source).encode(ExternalEncoding), input_name='Source'), namespace_, eol_))
        if self.Source_Sw_Version is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSource_Sw_Version>%s</%sSource_Sw_Version>%s' % (namespace_, self.gds_format_string(quote_xml(self.Source_Sw_Version).encode(ExternalEncoding), input_name='Source_Sw_Version'), namespace_, eol_))
        if self.Generation_Time is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGeneration_Time>%s</%sGeneration_Time>%s' % (namespace_, self.gds_format_string(quote_xml(self.Generation_Time).encode(ExternalEncoding), input_name='Generation_Time'), namespace_, eol_))
        if self.Validity_Start is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValidity_Start>%s</%sValidity_Start>%s' % (namespace_, self.gds_format_string(quote_xml(self.Validity_Start).encode(ExternalEncoding), input_name='Validity_Start'), namespace_, eol_))
        if self.Validity_Stop is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sValidity_Stop>%s</%sValidity_Stop>%s' % (namespace_, self.gds_format_string(quote_xml(self.Validity_Stop).encode(ExternalEncoding), input_name='Validity_Stop'), namespace_, eol_))
        if self.Start_Orbit_Number is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStart_Orbit_Number>%s</%sStart_Orbit_Number>%s' % (namespace_, self.gds_format_string(quote_xml(self.Start_Orbit_Number).encode(ExternalEncoding), input_name='Start_Orbit_Number'), namespace_, eol_))
        if self.Stop_Orbit_Number is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sStop_Orbit_Number>%s</%sStop_Orbit_Number>%s' % (namespace_, self.gds_format_string(quote_xml(self.Stop_Orbit_Number).encode(ExternalEncoding), input_name='Stop_Orbit_Number'), namespace_, eol_))
        if self.Geographic_Localization is not None:
            self.Geographic_Localization.export(outfile, level, namespace_, name_='Geographic_Localization', pretty_print=pretty_print)
        if self.Quality_Info is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQuality_Info>%s</%sQuality_Info>%s' % (namespace_, self.gds_format_float(self.Quality_Info, input_name='Quality_Info'), namespace_, eol_))
        if self.Data_Size is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sData_Size>%s</%sData_Size>%s' % (namespace_, self.gds_format_string(quote_xml(self.Data_Size).encode(ExternalEncoding), input_name='Data_Size'), namespace_, eol_))
        if self.File_Type is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFile_Type>%s</%sFile_Type>%s' % (namespace_, self.gds_format_string(quote_xml(self.File_Type).encode(ExternalEncoding), input_name='File_Type'), namespace_, eol_))
        if self.Detector is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDetector>%s</%sDetector>%s' % (namespace_, self.gds_format_string(quote_xml(self.Detector).encode(ExternalEncoding), input_name='Detector'), namespace_, eol_))
        if self.File_Class is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sFile_Class>%s</%sFile_Class>%s' % (namespace_, self.gds_format_string(quote_xml(self.File_Class).encode(ExternalEncoding), input_name='File_Class'), namespace_, eol_))
        if self.Sensor_Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSensor_Code>%s</%sSensor_Code>%s' % (namespace_, self.gds_format_string(quote_xml(self.Sensor_Code).encode(ExternalEncoding), input_name='Sensor_Code'), namespace_, eol_))
        if self.Sensor_Mode is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSensor_Mode>%s</%sSensor_Mode>%s' % (namespace_, self.gds_format_string(quote_xml(self.Sensor_Mode).encode(ExternalEncoding), input_name='Sensor_Mode'), namespace_, eol_))
        if self.Acquisition_Station is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAcquisition_Station>%s</%sAcquisition_Station>%s' % (namespace_, self.gds_format_string(quote_xml(self.Acquisition_Station).encode(ExternalEncoding), input_name='Acquisition_Station'), namespace_, eol_))
        if self.Processing_Station is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sProcessing_Station>%s</%sProcessing_Station>%s' % (namespace_, self.gds_format_string(quote_xml(self.Processing_Station).encode(ExternalEncoding), input_name='Processing_Station'), namespace_, eol_))
        if self.Satellite_Code is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSatellite_Code>%s</%sSatellite_Code>%s' % (namespace_, self.gds_format_string(quote_xml(self.Satellite_Code).encode(ExternalEncoding), input_name='Satellite_Code'), namespace_, eol_))
        if self.Ascending_Flag is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sAscending_Flag>%s</%sAscending_Flag>%s' % (namespace_, self.gds_format_string(quote_xml(self.Ascending_Flag).encode(ExternalEncoding), input_name='Ascending_Flag'), namespace_, eol_))
        if self.CloudPercentage is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sCloudPercentage>%s</%sCloudPercentage>%s' % (namespace_, self.gds_format_float(self.CloudPercentage, input_name='CloudPercentage'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='Inventory_Metadata'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.File_ID is not None:
            showIndent(outfile, level)
            outfile.write('File_ID=%s,\n' % quote_python(self.File_ID).encode(ExternalEncoding))
        if self.Parent_ID is not None:
            showIndent(outfile, level)
            outfile.write('Parent_ID=%s,\n' % quote_python(self.Parent_ID).encode(ExternalEncoding))
        if self.Group_ID is not None:
            showIndent(outfile, level)
            outfile.write('Group_ID=%s,\n' % quote_python(self.Group_ID).encode(ExternalEncoding))
        if self.File_Name is not None:
            showIndent(outfile, level)
            outfile.write('File_Name=%s,\n' % quote_python(self.File_Name).encode(ExternalEncoding))
        if self.File_Version is not None:
            showIndent(outfile, level)
            outfile.write('File_Version=%s,\n' % quote_python(self.File_Version).encode(ExternalEncoding))
        if self.System is not None:
            showIndent(outfile, level)
            outfile.write('System=%s,\n' % quote_python(self.System).encode(ExternalEncoding))
        if self.Source is not None:
            showIndent(outfile, level)
            outfile.write('Source=%s,\n' % quote_python(self.Source).encode(ExternalEncoding))
        if self.Source_Sw_Version is not None:
            showIndent(outfile, level)
            outfile.write('Source_Sw_Version=%s,\n' % quote_python(self.Source_Sw_Version).encode(ExternalEncoding))
        if self.Generation_Time is not None:
            showIndent(outfile, level)
            outfile.write('Generation_Time=%s,\n' % quote_python(self.Generation_Time).encode(ExternalEncoding))
        if self.Validity_Start is not None:
            showIndent(outfile, level)
            outfile.write('Validity_Start=%s,\n' % quote_python(self.Validity_Start).encode(ExternalEncoding))
        if self.Validity_Stop is not None:
            showIndent(outfile, level)
            outfile.write('Validity_Stop=%s,\n' % quote_python(self.Validity_Stop).encode(ExternalEncoding))
        if self.Start_Orbit_Number is not None:
            showIndent(outfile, level)
            outfile.write('Start_Orbit_Number=%s,\n' % quote_python(self.Start_Orbit_Number).encode(ExternalEncoding))
        if self.Stop_Orbit_Number is not None:
            showIndent(outfile, level)
            outfile.write('Stop_Orbit_Number=%s,\n' % quote_python(self.Stop_Orbit_Number).encode(ExternalEncoding))
        if self.Geographic_Localization is not None:
            showIndent(outfile, level)
            outfile.write('Geographic_Localization=model_.Geographic_LocalizationType(\n')
            self.Geographic_Localization.exportLiteral(outfile, level, name_='Geographic_Localization')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.Quality_Info is not None:
            showIndent(outfile, level)
            outfile.write('Quality_Info=%f,\n' % self.Quality_Info)
        if self.Data_Size is not None:
            showIndent(outfile, level)
            outfile.write('Data_Size=%s,\n' % quote_python(self.Data_Size).encode(ExternalEncoding))
        if self.File_Type is not None:
            showIndent(outfile, level)
            outfile.write('File_Type=%s,\n' % quote_python(self.File_Type).encode(ExternalEncoding))
        if self.Detector is not None:
            showIndent(outfile, level)
            outfile.write('Detector=%s,\n' % quote_python(self.Detector).encode(ExternalEncoding))
        if self.File_Class is not None:
            showIndent(outfile, level)
            outfile.write('File_Class=%s,\n' % quote_python(self.File_Class).encode(ExternalEncoding))
        if self.Sensor_Code is not None:
            showIndent(outfile, level)
            outfile.write('Sensor_Code=%s,\n' % quote_python(self.Sensor_Code).encode(ExternalEncoding))
        if self.Sensor_Mode is not None:
            showIndent(outfile, level)
            outfile.write('Sensor_Mode=%s,\n' % quote_python(self.Sensor_Mode).encode(ExternalEncoding))
        if self.Acquisition_Station is not None:
            showIndent(outfile, level)
            outfile.write('Acquisition_Station=%s,\n' % quote_python(self.Acquisition_Station).encode(ExternalEncoding))
        if self.Processing_Station is not None:
            showIndent(outfile, level)
            outfile.write('Processing_Station=%s,\n' % quote_python(self.Processing_Station).encode(ExternalEncoding))
        if self.Satellite_Code is not None:
            showIndent(outfile, level)
            outfile.write('Satellite_Code=%s,\n' % quote_python(self.Satellite_Code).encode(ExternalEncoding))
        if self.Ascending_Flag is not None:
            showIndent(outfile, level)
            outfile.write('Ascending_Flag=%s,\n' % quote_python(self.Ascending_Flag).encode(ExternalEncoding))
        if self.CloudPercentage is not None:
            showIndent(outfile, level)
            outfile.write('CloudPercentage=%f,\n' % self.CloudPercentage)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'File_ID':
            File_ID_ = child_.text
            File_ID_ = self.gds_validate_string(File_ID_, node, 'File_ID')
            self.File_ID = File_ID_
        elif nodeName_ == 'Parent_ID':
            Parent_ID_ = child_.text
            Parent_ID_ = self.gds_validate_string(Parent_ID_, node, 'Parent_ID')
            self.Parent_ID = Parent_ID_
        elif nodeName_ == 'Group_ID':
            Group_ID_ = child_.text
            Group_ID_ = self.gds_validate_string(Group_ID_, node, 'Group_ID')
            self.Group_ID = Group_ID_
        elif nodeName_ == 'File_Name':
            File_Name_ = child_.text
            File_Name_ = self.gds_validate_string(File_Name_, node, 'File_Name')
            self.File_Name = File_Name_
        elif nodeName_ == 'File_Version':
            File_Version_ = child_.text
            File_Version_ = self.gds_validate_string(File_Version_, node, 'File_Version')
            self.File_Version = File_Version_
        elif nodeName_ == 'System':
            System_ = child_.text
            System_ = self.gds_validate_string(System_, node, 'System')
            self.System = System_
        elif nodeName_ == 'Source':
            Source_ = child_.text
            Source_ = self.gds_validate_string(Source_, node, 'Source')
            self.Source = Source_
        elif nodeName_ == 'Source_Sw_Version':
            Source_Sw_Version_ = child_.text
            Source_Sw_Version_ = self.gds_validate_string(Source_Sw_Version_, node, 'Source_Sw_Version')
            self.Source_Sw_Version = Source_Sw_Version_
        elif nodeName_ == 'Generation_Time':
            Generation_Time_ = child_.text
            Generation_Time_ = self.gds_validate_string(Generation_Time_, node, 'Generation_Time')
            self.Generation_Time = Generation_Time_
        elif nodeName_ == 'Validity_Start':
            Validity_Start_ = child_.text
            Validity_Start_ = self.gds_validate_string(Validity_Start_, node, 'Validity_Start')
            self.Validity_Start = Validity_Start_
        elif nodeName_ == 'Validity_Stop':
            Validity_Stop_ = child_.text
            Validity_Stop_ = self.gds_validate_string(Validity_Stop_, node, 'Validity_Stop')
            self.Validity_Stop = Validity_Stop_
        elif nodeName_ == 'Start_Orbit_Number':
            Start_Orbit_Number_ = child_.text
            Start_Orbit_Number_ = self.gds_validate_string(Start_Orbit_Number_, node, 'Start_Orbit_Number')
            self.Start_Orbit_Number = Start_Orbit_Number_
        elif nodeName_ == 'Stop_Orbit_Number':
            Stop_Orbit_Number_ = child_.text
            Stop_Orbit_Number_ = self.gds_validate_string(Stop_Orbit_Number_, node, 'Stop_Orbit_Number')
            self.Stop_Orbit_Number = Stop_Orbit_Number_
        elif nodeName_ == 'Geographic_Localization':
            obj_ = Geographic_LocalizationType.factory()
            obj_.build(child_)
            self.Geographic_Localization = obj_
        elif nodeName_ == 'Quality_Info':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'Quality_Info')
            self.Quality_Info = fval_
        elif nodeName_ == 'Data_Size':
            Data_Size_ = child_.text
            Data_Size_ = self.gds_validate_string(Data_Size_, node, 'Data_Size')
            self.Data_Size = Data_Size_
        elif nodeName_ == 'File_Type':
            File_Type_ = child_.text
            File_Type_ = self.gds_validate_string(File_Type_, node, 'File_Type')
            self.File_Type = File_Type_
        elif nodeName_ == 'Detector':
            Detector_ = child_.text
            Detector_ = self.gds_validate_string(Detector_, node, 'Detector')
            self.Detector = Detector_
        elif nodeName_ == 'File_Class':
            File_Class_ = child_.text
            File_Class_ = self.gds_validate_string(File_Class_, node, 'File_Class')
            self.File_Class = File_Class_
        elif nodeName_ == 'Sensor_Code':
            Sensor_Code_ = child_.text
            Sensor_Code_ = self.gds_validate_string(Sensor_Code_, node, 'Sensor_Code')
            self.Sensor_Code = Sensor_Code_
        elif nodeName_ == 'Sensor_Mode':
            Sensor_Mode_ = child_.text
            Sensor_Mode_ = self.gds_validate_string(Sensor_Mode_, node, 'Sensor_Mode')
            self.Sensor_Mode = Sensor_Mode_
        elif nodeName_ == 'Acquisition_Station':
            Acquisition_Station_ = child_.text
            Acquisition_Station_ = self.gds_validate_string(Acquisition_Station_, node, 'Acquisition_Station')
            self.Acquisition_Station = Acquisition_Station_
        elif nodeName_ == 'Processing_Station':
            Processing_Station_ = child_.text
            Processing_Station_ = self.gds_validate_string(Processing_Station_, node, 'Processing_Station')
            self.Processing_Station = Processing_Station_
        elif nodeName_ == 'Satellite_Code':
            Satellite_Code_ = child_.text
            Satellite_Code_ = self.gds_validate_string(Satellite_Code_, node, 'Satellite_Code')
            self.Satellite_Code = Satellite_Code_
        elif nodeName_ == 'Ascending_Flag':
            Ascending_Flag_ = child_.text
            Ascending_Flag_ = self.gds_validate_string(Ascending_Flag_, node, 'Ascending_Flag')
            self.Ascending_Flag = Ascending_Flag_
        elif nodeName_ == 'CloudPercentage':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'CloudPercentage')
            self.CloudPercentage = fval_
# end class Inventory_Metadata


class File_ID(GeneratedsSuper):
    """PDI_ID (Applicable to Granule, Tile, DataStrip and SAD PDI)"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if File_ID.subclass:
            return File_ID.subclass(*args_, **kwargs_)
        else:
            return File_ID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='File_ID', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='File_ID')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='File_ID'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='File_ID', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='File_ID'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class File_ID


class Parent_ID(GeneratedsSuper):
    """DataStrip PDI_ID (Applicable to Granule and Tile PDI linked to a
    DataStrip PDI)"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Parent_ID.subclass:
            return Parent_ID.subclass(*args_, **kwargs_)
        else:
            return Parent_ID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Parent_ID', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Parent_ID')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Parent_ID'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Parent_ID', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Parent_ID'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Parent_ID


class Group_ID(GeneratedsSuper):
    """Label identifying all the PDIs that can be included in a User
    Product (Applicable to Granule, Tile and Datastrip PDI)
    (Applicable to Granule, Tile and DataStrip and PDI)"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Group_ID.subclass:
            return Group_ID.subclass(*args_, **kwargs_)
        else:
            return Group_ID(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Group_ID', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Group_ID')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Group_ID'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Group_ID', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Group_ID'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Group_ID


class File_Name(GeneratedsSuper):
    """Equal to File_ID metadata (Applicable to Granule, Tile, DataStrip
    and SAD PDI)"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if File_Name.subclass:
            return File_Name.subclass(*args_, **kwargs_)
        else:
            return File_Name(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='File_Name', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='File_Name')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='File_Name'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='File_Name', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='File_Name'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class File_Name


class File_Version(GeneratedsSuper):
    """Processing Baseline (Applicable to Granule, Tile and DataStrip PDI)"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if File_Version.subclass:
            return File_Version.subclass(*args_, **kwargs_)
        else:
            return File_Version(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='File_Version', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='File_Version')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='File_Version'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='File_Version', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='File_Version'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class File_Version


class System(GeneratedsSuper):
    """System where the PDI is generated by DPC or MCC (Applicable to
    Granule, Tile, DataStrip and SAD PDI)"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if System.subclass:
            return System.subclass(*args_, **kwargs_)
        else:
            return System(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='System', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='System')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='System'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='System', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='System'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class System


class Source(GeneratedsSuper):
    """PDI generator processor name (Applicable to Granule, Tile, DataStrip
    and SAD PDI)"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Source.subclass:
            return Source.subclass(*args_, **kwargs_)
        else:
            return Source(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Source', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Source')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Source'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Source', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Source'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Source


class Source_Sw_Version(GeneratedsSuper):
    """Version of the core component ie version of DPC (Applicable to
    Granule, Tile, DataStrip and SAD PDI)"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Source_Sw_Version.subclass:
            return Source_Sw_Version.subclass(*args_, **kwargs_)
        else:
            return Source_Sw_Version(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Source_Sw_Version', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Source_Sw_Version')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Source_Sw_Version'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Source_Sw_Version', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Source_Sw_Version'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Source_Sw_Version


class Generation_Time(GeneratedsSuper):
    """PDI Generation Time (Applicable to Granule, Tile, DataStrip and SAD
    PDI) Template: UTC=2013-01-01T,5:11:10"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Generation_Time.subclass:
            return Generation_Time.subclass(*args_, **kwargs_)
        else:
            return Generation_Time(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Generation_Time', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Generation_Time')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Generation_Time'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Generation_Time', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Generation_Time'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Generation_Time


class Validity_Start(GeneratedsSuper):
    """Sensing Start Time or Validity Start Time (Applicable to Granule,
    Tile, DataStrip and SAD PDI) Template: UTC=2013-01-01T,5:11:10"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Validity_Start.subclass:
            return Validity_Start.subclass(*args_, **kwargs_)
        else:
            return Validity_Start(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Validity_Start', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Validity_Start')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Validity_Start'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Validity_Start', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Validity_Start'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Validity_Start


class Validity_Stop(GeneratedsSuper):
    """Sensing Start Time or Validity Stop Time (Applicable to Granule,
    Tile, DataStrip and SAD PDI) Template: UTC=2013-01-01T,5:11:10"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Validity_Stop.subclass:
            return Validity_Stop.subclass(*args_, **kwargs_)
        else:
            return Validity_Stop(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Validity_Stop', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Validity_Stop')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Validity_Stop'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Validity_Stop', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Validity_Stop'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Validity_Stop


class Start_Orbit_Number(GeneratedsSuper):
    """Start Absolute Orbit number (Applicable to Granule, Tile, DataStrip
    and SAD PDI)"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Start_Orbit_Number.subclass:
            return Start_Orbit_Number.subclass(*args_, **kwargs_)
        else:
            return Start_Orbit_Number(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Start_Orbit_Number', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Start_Orbit_Number')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Start_Orbit_Number'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Start_Orbit_Number', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Start_Orbit_Number'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Start_Orbit_Number


class Stop_Orbit_Number(GeneratedsSuper):
    """Stop Absolute Orbit number will be the same of Start Absolute Orbit
    number (Applicable to Granule, Tile, DataStrip and SAD PDI)"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Stop_Orbit_Number.subclass:
            return Stop_Orbit_Number.subclass(*args_, **kwargs_)
        else:
            return Stop_Orbit_Number(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Stop_Orbit_Number', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Stop_Orbit_Number')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Stop_Orbit_Number'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Stop_Orbit_Number', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Stop_Orbit_Number'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Stop_Orbit_Number


class Quality_Info(GeneratedsSuper):
    """Percentage for PDI Quality Indicator (Applicable to Granule, Tile,
    DataStrip and SAD PDI)"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Quality_Info.subclass:
            return Quality_Info.subclass(*args_, **kwargs_)
        else:
            return Quality_Info(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Quality_Info', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Quality_Info')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Quality_Info'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Quality_Info', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Quality_Info'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Quality_Info


class File_Type(GeneratedsSuper):
    """PDI File Type (Applicable to Granule, Tile, DataStrip and SAD PDI)"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if File_Type.subclass:
            return File_Type.subclass(*args_, **kwargs_)
        else:
            return File_Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='File_Type', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='File_Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='File_Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='File_Type', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='File_Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class File_Type


class Detector(GeneratedsSuper):
    """Detector ID (Applicable for Granule PDI)"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Detector.subclass:
            return Detector.subclass(*args_, **kwargs_)
        else:
            return Detector(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Detector', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Detector')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Detector'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Detector', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Detector'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Detector


class File_Class(GeneratedsSuper):
    """Timeliness (Applicable to Granule, Tile and DataStrip PDI)"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if File_Class.subclass:
            return File_Class.subclass(*args_, **kwargs_)
        else:
            return File_Class(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='File_Class', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='File_Class')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='File_Class'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='File_Class', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='File_Class'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class File_Class


class Sensor_Code(GeneratedsSuper):
    """MSI fixed string (Applicable to Granule, Tile, DataStrip and SAD
    PDI)"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Sensor_Code.subclass:
            return Sensor_Code.subclass(*args_, **kwargs_)
        else:
            return Sensor_Code(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Sensor_Code', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Sensor_Code')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Sensor_Code'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Sensor_Code', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Sensor_Code'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Sensor_Code


class Sensor_Mode(GeneratedsSuper):
    """MSI Image mode (Applicable to Granule, Tile and DataStrip PDI)"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Sensor_Mode.subclass:
            return Sensor_Mode.subclass(*args_, **kwargs_)
        else:
            return Sensor_Mode(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Sensor_Mode', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Sensor_Mode')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Sensor_Mode'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Sensor_Mode', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Sensor_Mode'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Sensor_Mode


class Acquisition_Station(GeneratedsSuper):
    """Acquisition Station Code (Applicable to Granule, Tile, DataStrip and
    SAD PDI)"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Acquisition_Station.subclass:
            return Acquisition_Station.subclass(*args_, **kwargs_)
        else:
            return Acquisition_Station(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Acquisition_Station', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Acquisition_Station')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Acquisition_Station'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Acquisition_Station', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Acquisition_Station'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Acquisition_Station


class Processing_Station(GeneratedsSuper):
    """Processing Station Code, equal to System metadata (Applicable to
    Granule, Tile, DataStrip and SAD PDI)"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Processing_Station.subclass:
            return Processing_Station.subclass(*args_, **kwargs_)
        else:
            return Processing_Station(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Processing_Station', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Processing_Station')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Processing_Station'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Processing_Station', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Processing_Station'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Processing_Station


class Satellite_Code(GeneratedsSuper):
    """S2A or S2B. NIL if applicable to both satellites"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Satellite_Code.subclass:
            return Satellite_Code.subclass(*args_, **kwargs_)
        else:
            return Satellite_Code(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Satellite_Code', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Satellite_Code')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Satellite_Code'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Satellite_Code', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Satellite_Code'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Satellite_Code


class Ascending_Flag(GeneratedsSuper):
    """True if acquisition has been done during the ascending phase of the
    orbit. Field not applicable in case of SAD data"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if Ascending_Flag.subclass:
            return Ascending_Flag.subclass(*args_, **kwargs_)
        else:
            return Ascending_Flag(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Ascending_Flag', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Ascending_Flag')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Ascending_Flag'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Ascending_Flag', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='Ascending_Flag'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class Ascending_Flag


class CloudPercentage(GeneratedsSuper):
    """Cloud coverage percentage. Empty string in case of SAD"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if CloudPercentage.subclass:
            return CloudPercentage.subclass(*args_, **kwargs_)
        else:
            return CloudPercentage(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CloudPercentage', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CloudPercentage')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CloudPercentage'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CloudPercentage', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='CloudPercentage'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class CloudPercentage


class A_JULIAN_DAY(GeneratedsSuper):
    """Jour julien CNES"""
    subclass = None
    superclass = None
    def __init__(self, D=None, S=None):
        self.D = D
        self.S = S
    def factory(*args_, **kwargs_):
        if A_JULIAN_DAY.subclass:
            return A_JULIAN_DAY.subclass(*args_, **kwargs_)
        else:
            return A_JULIAN_DAY(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_D(self): return self.D
    def set_D(self, D): self.D = D
    def get_S(self): return self.S
    def set_S(self, S): self.S = S
    def hasContent_(self):
        if (
            self.D is not None or
            self.S is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='A_JULIAN_DAY', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='A_JULIAN_DAY')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='A_JULIAN_DAY'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='A_JULIAN_DAY', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.D is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sD>%s</%sD>%s' % (namespace_, self.gds_format_integer(self.D, input_name='D'), namespace_, eol_))
        if self.S is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sS>%s</%sS>%s' % (namespace_, self.gds_format_double(self.S, input_name='S'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='A_JULIAN_DAY'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.D is not None:
            showIndent(outfile, level)
            outfile.write('D=%d,\n' % self.D)
        if self.S is not None:
            showIndent(outfile, level)
            outfile.write('S=%e,\n' % self.S)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'D':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'D')
            self.D = ival_
        elif nodeName_ == 'S':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'S')
            self.S = fval_
# end class A_JULIAN_DAY


class D(GeneratedsSuper):
    """Julian Day"""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if D.subclass:
            return D.subclass(*args_, **kwargs_)
        else:
            return D(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='D', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='D')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='D'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='D', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='D'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class D


class S(GeneratedsSuper):
    """Number of seconds (can be more than the number of seconds in a day)."""
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if S.subclass:
            return S.subclass(*args_, **kwargs_)
        else:
            return S(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='S', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='S')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='S'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='S', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='S'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class S


class Geographic_LocalizationType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, GEO_TYPE=None, List_Of_Geo_Pnt=None):
        self.GEO_TYPE = GEO_TYPE
        self.List_Of_Geo_Pnt = List_Of_Geo_Pnt
    def factory(*args_, **kwargs_):
        if Geographic_LocalizationType.subclass:
            return Geographic_LocalizationType.subclass(*args_, **kwargs_)
        else:
            return Geographic_LocalizationType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_GEO_TYPE(self): return self.GEO_TYPE
    def set_GEO_TYPE(self, GEO_TYPE): self.GEO_TYPE = GEO_TYPE
    def get_List_Of_Geo_Pnt(self): return self.List_Of_Geo_Pnt
    def set_List_Of_Geo_Pnt(self, List_Of_Geo_Pnt): self.List_Of_Geo_Pnt = List_Of_Geo_Pnt
    def hasContent_(self):
        if (
            self.GEO_TYPE is not None or
            self.List_Of_Geo_Pnt is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Geographic_LocalizationType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Geographic_LocalizationType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Geographic_LocalizationType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Geographic_LocalizationType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.GEO_TYPE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sGEO_TYPE>%s</%sGEO_TYPE>%s' % (namespace_, self.gds_format_string(quote_xml(self.GEO_TYPE).encode(ExternalEncoding), input_name='GEO_TYPE'), namespace_, eol_))
        if self.List_Of_Geo_Pnt is not None:
            self.List_Of_Geo_Pnt.export(outfile, level, namespace_, name_='List_Of_Geo_Pnt', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='Geographic_LocalizationType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.GEO_TYPE is not None:
            showIndent(outfile, level)
            outfile.write('GEO_TYPE=%s,\n' % quote_python(self.GEO_TYPE).encode(ExternalEncoding))
        if self.List_Of_Geo_Pnt is not None:
            showIndent(outfile, level)
            outfile.write('List_Of_Geo_Pnt=model_.List_Of_Geo_PntType(\n')
            self.List_Of_Geo_Pnt.exportLiteral(outfile, level, name_='List_Of_Geo_Pnt')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'GEO_TYPE':
            GEO_TYPE_ = child_.text
            GEO_TYPE_ = self.gds_validate_string(GEO_TYPE_, node, 'GEO_TYPE')
            self.GEO_TYPE = GEO_TYPE_
        elif nodeName_ == 'List_Of_Geo_Pnt':
            obj_ = List_Of_Geo_PntType.factory()
            obj_.build(child_)
            self.List_Of_Geo_Pnt = obj_
# end class Geographic_LocalizationType


class GEO_TYPE(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if GEO_TYPE.subclass:
            return GEO_TYPE.subclass(*args_, **kwargs_)
        else:
            return GEO_TYPE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='GEO_TYPE', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='GEO_TYPE')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='GEO_TYPE'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='GEO_TYPE', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='GEO_TYPE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class GEO_TYPE


class List_Of_Geo_PntType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, count=None, Geo_Pnt=None):
        self.count = _cast(int, count)
        if Geo_Pnt is None:
            self.Geo_Pnt = []
        else:
            self.Geo_Pnt = Geo_Pnt
    def factory(*args_, **kwargs_):
        if List_Of_Geo_PntType.subclass:
            return List_Of_Geo_PntType.subclass(*args_, **kwargs_)
        else:
            return List_Of_Geo_PntType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_Geo_Pnt(self): return self.Geo_Pnt
    def set_Geo_Pnt(self, Geo_Pnt): self.Geo_Pnt = Geo_Pnt
    def add_Geo_Pnt(self, value): self.Geo_Pnt.append(value)
    def insert_Geo_Pnt(self, index, value): self.Geo_Pnt[index] = value
    def get_count(self): return self.count
    def set_count(self, count): self.count = count
    def hasContent_(self):
        if (
            self.Geo_Pnt
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='List_Of_Geo_PntType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='List_Of_Geo_PntType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='List_Of_Geo_PntType'):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            outfile.write(' count="%s"' % self.gds_format_integer(self.count, input_name='count'))
    def exportChildren(self, outfile, level, namespace_='', name_='List_Of_Geo_PntType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for Geo_Pnt_ in self.Geo_Pnt:
            Geo_Pnt_.export(outfile, level, namespace_, name_='Geo_Pnt', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='List_Of_Geo_PntType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.count is not None and 'count' not in already_processed:
            already_processed.add('count')
            showIndent(outfile, level)
            outfile.write('count=%d,\n' % (self.count,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('Geo_Pnt=[\n')
        level += 1
        for Geo_Pnt_ in self.Geo_Pnt:
            showIndent(outfile, level)
            outfile.write('model_.Geo_PntType(\n')
            Geo_Pnt_.exportLiteral(outfile, level, name_='Geo_PntType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('count', node)
        if value is not None and 'count' not in already_processed:
            already_processed.add('count')
            try:
                self.count = int(value)
            except ValueError, exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.count <= 0:
                raise_parse_error(node, 'Invalid PositiveInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'Geo_Pnt':
            obj_ = Geo_PntType.factory()
            obj_.build(child_)
            self.Geo_Pnt.append(obj_)
# end class List_Of_Geo_PntType


class Geo_PntType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LATITUDE=None, LONGITUDE=None):
        self.LATITUDE = LATITUDE
        self.LONGITUDE = LONGITUDE
    def factory(*args_, **kwargs_):
        if Geo_PntType.subclass:
            return Geo_PntType.subclass(*args_, **kwargs_)
        else:
            return Geo_PntType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LATITUDE(self): return self.LATITUDE
    def set_LATITUDE(self, LATITUDE): self.LATITUDE = LATITUDE
    def get_LONGITUDE(self): return self.LONGITUDE
    def set_LONGITUDE(self, LONGITUDE): self.LONGITUDE = LONGITUDE
    def hasContent_(self):
        if (
            self.LATITUDE is not None or
            self.LONGITUDE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='Geo_PntType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='Geo_PntType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='Geo_PntType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='Geo_PntType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LATITUDE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLATITUDE>%s</%sLATITUDE>%s' % (namespace_, self.gds_format_float(self.LATITUDE, input_name='LATITUDE'), namespace_, eol_))
        if self.LONGITUDE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLONGITUDE>%s</%sLONGITUDE>%s' % (namespace_, self.gds_format_float(self.LONGITUDE, input_name='LONGITUDE'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='Geo_PntType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LATITUDE is not None:
            showIndent(outfile, level)
            outfile.write('LATITUDE=%f,\n' % self.LATITUDE)
        if self.LONGITUDE is not None:
            showIndent(outfile, level)
            outfile.write('LONGITUDE=%f,\n' % self.LONGITUDE)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LATITUDE':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'LATITUDE')
            self.LATITUDE = fval_
        elif nodeName_ == 'LONGITUDE':
            sval_ = child_.text
            try:
                fval_ = float(sval_)
            except (TypeError, ValueError), exp:
                raise_parse_error(child_, 'requires float or double: %s' % exp)
            fval_ = self.gds_validate_float(fval_, node, 'LONGITUDE')
            self.LONGITUDE = fval_
# end class Geo_PntType


class LATITUDE(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if LATITUDE.subclass:
            return LATITUDE.subclass(*args_, **kwargs_)
        else:
            return LATITUDE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LATITUDE', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LATITUDE')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LATITUDE'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LATITUDE', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='LATITUDE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LATITUDE


class LONGITUDE(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self):
        pass
    def factory(*args_, **kwargs_):
        if LONGITUDE.subclass:
            return LONGITUDE.subclass(*args_, **kwargs_)
        else:
            return LONGITUDE(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LONGITUDE', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LONGITUDE')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_, name_, pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LONGITUDE'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LONGITUDE', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='LONGITUDE'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class LONGITUDE


GDSClassesMapping = {
    'Geographic_Localization': Geographic_LocalizationType,
    'List_Of_Geo_Pnt': List_Of_Geo_PntType,
    'Geo_Pnt': Geo_PntType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print USAGE_TEXT
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Inventory_Metadata'
        rootClass = Inventory_Metadata
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(
        sys.stdout, 0, name_=rootTag,
        namespacedef_='',
        pretty_print=True)
    return rootObj


def parseEtree(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Inventory_Metadata'
        rootClass = Inventory_Metadata
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    content = etree_.tostring(
        rootElement, pretty_print=True,
        xml_declaration=True, encoding="utf-8")
    sys.stdout.write(content)
    sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString):
    from StringIO import StringIO
    doc = parsexml_(StringIO(inString))
    rootNode = doc.getroot()
    roots = get_root_tag(rootNode)
    rootClass = roots[1]
    if rootClass is None:
        rootClass = Inventory_Metadata
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('<?xml version="1.0" ?>\n')
    rootObj.export(
        sys.stdout, 0, name_="Inventory_Metadata",
        namespacedef_='')
    return rootObj


def parseLiteral(inFileName):
    doc = parsexml_(inFileName)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'Inventory_Metadata'
        rootClass = Inventory_Metadata
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    sys.stdout.write('#from Inventory_Metadata import *\n\n')
    sys.stdout.write('import Inventory_Metadata as model_\n\n')
    sys.stdout.write('rootObj = model_.rootTag(\n')
    rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
    sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "A_JULIAN_DAY",
    "Acquisition_Station",
    "Ascending_Flag",
    "CloudPercentage",
    "D",
    "Detector",
    "File_Class",
    "File_ID",
    "File_Name",
    "File_Type",
    "File_Version",
    "GEO_TYPE",
    "Generation_Time",
    "Geo_PntType",
    "Geographic_LocalizationType",
    "Group_ID",
    "Inventory_Metadata",
    "LATITUDE",
    "LONGITUDE",
    "List_Of_Geo_PntType",
    "Parent_ID",
    "Processing_Station",
    "Quality_Info",
    "S",
    "Satellite_Code",
    "Sensor_Code",
    "Sensor_Mode",
    "Source",
    "Source_Sw_Version",
    "Start_Orbit_Number",
    "Stop_Orbit_Number",
    "System",
    "Validity_Start",
    "Validity_Stop"
]
