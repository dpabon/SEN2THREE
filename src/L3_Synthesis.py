#!/usr/bin/env python#import os#import sys#import Imagefrom numpy import *#from scipy.ndimage.filters import median_filter#from scipy.ndimage.morphology import *from time import timefrom L3_Borg import Borgfrom L3_Library import stderrWrite, stdoutWrite, showImagefrom L3_XmlParser import L3_XmlParserfrom L3_Display import L3_Displayfrom scipy.stats import itemfreqclass L3_Synthesis(Borg):    def __init__(self, config, tables):        self._config = config        self._tables = tables        self._badPixelMask2A = None        self._goodPixelMask2A = None        self._badPixelMask03 = None        self._goodPixelMask03 = None        self._goodPixelRatio = None             self._aot2A = None        self._sza2A = None        self._aot03 = None        self._sza03 = None        self._isBetterScene = False        self._bestSZA = 0.0            self._noData = self.config.classifier['NO_DATA']        self._saturatedDefective = self.config.classifier['SATURATED_DEFECTIVE']        self._darkFeatures = self.config.classifier['DARK_FEATURES']        self._bareSoils = self.config.classifier['BARE_SOILS']        self._snowIce = self.config.classifier['SNOW_ICE']        self._vegetation = self.config.classifier['VEGETATION']        self._water = self.config.classifier['WATER']        self._lowProbaClouds = self.config.classifier['LOW_PROBA_CLOUDS']        self._medProbaClouds = self.config.classifier['MEDIUM_PROBA_CLOUDS']        self._highProbaClouds = self.config.classifier['HIGH_PROBA_CLOUDS']        self._thinCirrus = self.config.classifier['THIN_CIRRUS']        self._cloudShadows = self.config.classifier['CLOUD_SHADOWS']        if self._config.displayData == True:            self._display = L3_Display(config, tables)        else:            self._display = None        self.config.logger.debug('Module L3_STP initialized')        self._processingStatus = True        def get_config(self):        return self._config    def get_tables(self):        return self._tables    def set_config(self, value):        self._config = value    def set_tables(self, value):        self._tables = value    def del_config(self):        del self._config    def del_tables(self):        del self._tables    config = property(get_config, set_config, del_config, "config's docstring")    tables = property(get_tables, set_tables, del_tables, "tables's docstring")    def setPixelMasks(self):        noData = self._noData        bareSoils = self._bareSoils        vegetation = self._vegetation        water = self._water        cirrus = self._thinCirrus        darkFeatures = self._darkFeatures        cloudShadows = self._cloudShadows        snowIce = self._snowIce        ntProcessed = self.config.nrTilesProcessed                        scl2A = self.tables.getBand('L2A', self.tables.SCL)        scl2A[scl2A > 11] = 9        self.tables.setBand('L2A', self.tables.SCL, scl2A)                scl03 = self.tables.getBand('L3', self.tables.SCL)        scl03[scl03 > 11] = 9        self.tables.setBand('L3', self.tables.SCL, scl03)                        GPM2A = zeros_like(scl2A)        GPM2A[(scl2A == bareSoils) | (scl2A == vegetation) | (scl2A == water)] = 1        if self.config.cirrusRemoval == False:            GPM2A[scl2A == cirrus] = 1        if self.config.shadowRemoval == False:            GPM2A[(scl2A == darkFeatures) | (scl2A == cloudShadows)] = 1        if  self.config.snowRemoval == False:            GPM2A[scl2A == snowIce] = 1        GPM03 = zeros_like(scl03)        GPM03[(scl03 == bareSoils) | (scl03 == vegetation) | (scl03 == water)] = 1        if self.config.cirrusRemoval == False:            GPM03[scl03 == cirrus] = 1        if self.config.shadowRemoval == False:            GPM03[(scl03 == darkFeatures) | (scl03 == cloudShadows)] = 1        if  self.config.snowRemoval == False:            GPM03[scl03 == snowIce] = 1        # Create mosaic map if not exist, else read from table:        if self.tables.testBand('L3', self.tables.MSC) == False:            mosaicMap = zeros_like(scl2A, dtype=uint8)            mosaicMap[GPM03 == 1] = 1            self.tables.setBand('L3', self.tables.MSC, mosaicMap)        else:            mosaicMap = self.tables.getBand('L3', self.tables.MSC)        if self.config.priority == 'MOST_RECENT':            # previous scene will always be replaced by good pixels of recent scene:            scl03[GPM2A == 1] = scl2A[GPM2A == 1]            mosaicMap[GPM2A == 1] = ntProcessed                           elif self.config.priority == 'TEMP_HOMOGENEITY':            # previous scene will only be replaced if sum of current good pixels            # is better than sum of good pixels of the best scene in the past:            GP2Asum = (GPM2A[GPM2A == 1]).sum()            mmif = itemfreq(mosaicMap[GPM03 == 1])            bestScenePast = (mmif[:,1]).max()            if(GP2Asum / bestScenePast) > 1.0:                self._isBetterScene = True            else:                self._isBetterScene = False            if self._isBetterScene:                scl03[GPM2A == 1] = scl2A[GPM2A == 1]                mosaicMap[GPM2A == 1] = ntProcessed            else: # fill only the bad pixels with good ones:                scl03[(GPM2A == 1) & (GPM03 == 0)] = scl2A[(GPM2A == 1) & (GPM03 == 0)]                mosaicMap[(GPM2A == 1) & (GPM03 == 0)] = ntProcessed        elif self.config.priority == 'RADIOMETRIC_QUALITY':            # previous scene will be replaced if either:            # - the average of the current AOT or            # - the average of the current Solar Zenith Angle            # is better than the equivalent parameter of the best scene in the past:            if self.config.radiometricPreference == 'SOLAR_ZENITH':                sza2A = self.readSolarZenithAngle('T2A')                bestSzaPast = self._bestSZA                if sza2A > bestSzaPast:                    scl03[(GPM2A == 1)] = scl2A[(GPM2A == 1)]                    mosaicMap[GPM2A == 1] = ntProcessed                    self._bestSZA = sza2A                else:                    scl03[(GPM2A == 1) & (GPM03 == 0)] = scl2A[(GPM2A == 1) & (GPM03 == 0)]                    mosaicMap[(GPM2A == 1) & (GPM03 == 0)] = ntProcessed            else: # AOT:                aotArr2A = self.tables.getBand('L2A', self.tables.AOT)                aotMean2A = (aotArr2A[GPM2A == 1]).mean()                aotArr03 = self.tables.getBand('L3', self.tables.AOT)                aotMean03 = (aotArr03[GPM03 == 1]).mean()                          if aotMean2A < aotMean03: # lower is better!                    scl03[(GPM2A == 1)] = scl2A[(GPM2A == 1)]                    mosaicMap[GPM2A == 1] = ntProcessed                    self.tables.setBand('L3', self.tables.AOT, aotArr2A)                else:                    scl03[(GPM2A == 1) & (GPM03 == 0)] = scl2A[(GPM2A == 1) & (GPM03 == 0)]                    mosaicMap[(GPM2A == 1) & (GPM03 == 0)] = ntProcessed                elif self.config.priority == 'AVERAGE':            # images are an average of the current good pixels and the            # good pixels of all previous scenes. Mosaic map is the per pixel sum            # of all good pixels in the past and is used for calculating the average:            scl03[(GPM2A == 1) & (GPM03 == 0)] = scl2A[(GPM2A == 1) & (GPM03 == 0)]            mosaicMap[GPM2A == 1] = mosaicMap[GPM2A == 1] + 1                    self.tables.setBand('L3', self.tables.SCL, scl03)        self.tables.setBand('L3', self.tables.MSC, mosaicMap)        self._goodPixelMask2A = GPM2A        self._goodPixelMask03 = GPM03        if self._display != None:            self._display.displayData()                    return    def replaceBadPixels(self, bandIndex):        BL2A = self.tables.getBand('L2A', bandIndex)        BL03 = self.tables.getBand('L3', bandIndex)        GPM2A = self._goodPixelMask2A        GPM03 = self._goodPixelMask03                if self.config.priority == 'MOST_RECENT':            # previous scene will always be replaced by good pixels of recent scene:            BL03[(GPM2A == 1)] = BL2A[(GPM2A == 1)]                           elif self.config.priority == 'TEMP_HOMOGENEITY':            # previous scene will only be replaced if sum of current good pixels            # is better than sum of good pixels of the best scene in the past:            if self._isBetterScene:                BL03[(GPM2A == 1)] = BL2A[(GPM2A == 1)]            else: # fill only the bad pixels with good ones:                BL03[(GPM2A == 1) & (GPM03 == 0)] = BL2A[(GPM2A == 1) & (GPM03 == 0)]        elif self.config.priority == 'RADIOMETRIC_QUALITY':            # previous scene will be replaced if either:            # - the average of the current AOT or            # - the average of the current Solar Zenith Angle            # is better than the equivalent parameter of the best scene in the past:            if self._isBetterScene:                BL03[(GPM2A == 1)] = BL03[(GPM2A == 1)]            else:                BL03[(GPM2A == 1) & (GPM03 == 0)] = BL2A[(GPM2A == 1) & (GPM03 == 0)]                                    elif self.config.priority == 'AVERAGE':            # new scene is an average of the current good pixels and the            # good pixels of all previous scenes:            mosaicMap = self.tables.getBand('L3', self.tables.MSC)            BL03[GPM2A == 1] = (BL03[GPM2A == 1] * mosaicMap[GPM2A == 1] + \                                BL2A[GPM2A == 1]) / (BL03[GPM2A == 1] + 1)                    self.tables.setBand('L3', bandIndex, BL03)        return        def readSolarZenithAngle(self, product):        xp = L3_XmlParser(self.config, product)        ang = xp.getTree('Geometric_Info', 'Tile_Angles')        sza = float32(ang.Mean_Sun_Angle.ZENITH_ANGLE.text)        sza = absolute(sza)        if sza > 70.0: sza = 70.0        return sza            def preProcessing(self):        self.setPixelMasks()        return    def forwardProcessing(self):        # this is the default processing routine: it removes clouds and dark features        # from an input image        for i in self.tables.bandIndex:            self.replaceBadPixels(i)        return True    def inverseProcessing(self):        # This is the other way round: it applies clouds and dark features        # to an input image in order to generate suitable test images.        if self.tables.testBand('L2A', 1) == False:            return False        for i in self.tables.bandIndex:            self.replaceGoodPixels(i)        return True    def postProcessing(self):        # ToDo: Implement here ...        if(self._processingStatus == False):            return False        return True        def __exit__(self):        sys.exit(-1)    def __del__(self):        self.config.logger.info('Module L3_Synthesis deleted')            def process(self):        ts = time()        self.config.timestamp('L3_Synthesis Pre-processing    ')        self.preProcessing()        #self.config.timestamp('L3_Synthesis Inverse Processing')        #self.inverseProcessing()        self.config.timestamp('L3_Synthesis Processing        ')        self.forwardProcessing()        self.config.timestamp('L3_Synthesis Post-processing   ')        self.postProcessing()        tDelta = time() - ts        self.config.logger.info('Procedure L3_Synthesis overall time [s]: %0.3f' % tDelta)        if(self.config.loglevel == 'DEBUG'):            stdoutWrite('Procedure L3_Synthesis, overall time[s]: %0.3f\n.' % tDelta)        return True