#!/usr/bin/env pythonimport osimport sysimport Imagefrom numpy import *from scipy.misc import imresizefrom scipy.ndimage.filters import median_filterfrom scipy.ndimage.morphology import *from time import timefrom L3_Borg import Borgfrom L3_Library import stdoutWrite, stdoutWrite, showImage, rectBivariateSplinefrom L3_XmlParser import L3_XmlParserset_printoptions(precision = 7, suppress = True)class L3_Synthesis(Borg):    def __init__(self, config, tables):        self._config = config        self._tables = tables        self._badPixelMask2A = None        self._goodPixelMask2A = None        self._badPixelMask03 = None        self._goodPixelMask03 = None        self._goodPixelRatio = None             self._aot2A = None        self._sza2A = None        self._aot03 = None        self._sza03 = None        self._noData = self.config.classifier['NO_DATA']        self._saturatedDefective = self.config.classifier['SATURATED_DEFECTIVE']        self._darkFeatures = self.config.classifier['DARK_FEATURES']        self._bareSoils = self.config.classifier['BARE_SOILS']        self._snowIce = self.config.classifier['SNOW_ICE']        self._vegetation = self.config.classifier['VEGETATION']        self._water = self.config.classifier['WATER']        self._lowProbaClouds = self.config.classifier['LOW_PROBA_CLOUDS']        self._medProbaClouds = self.config.classifier['MEDIUM_PROBA_CLOUDS']        self._highProbaClouds = self.config.classifier['HIGH_PROBA_CLOUDS']        self._thinCirrus = self.config.classifier['THIN_CIRRUS']        self._cloudShadows = self.config.classifier['CLOUD_SHADOWS']        self.config.logger.debug('Module L3_STP initialized')        self._processingStatus = True        def get_config(self):        return self._config    def get_tables(self):        return self._tables    def set_config(self, value):        self._config = value    def set_tables(self, value):        self._tables = value    def del_config(self):        del self._config    def del_tables(self):        del self._tables    config = property(get_config, set_config, del_config, "config's docstring")    tables = property(get_tables, set_tables, del_tables, "tables's docstring")    def setPixelMasks(self):                noData = self._noData        bareSoils = self._bareSoils        vegetation = self._vegetation        water = self._water        cirrus = self._thinCirrus        darkFeatures = self._darkFeatures        cloudShadows = self._cloudShadows        snowIce = self._snowIce                scl2A = self.tables.getBand('L2A', self.tables.SCL)        scl03 = self.tables.getBand('L3', self.tables.SCL)        #self._sza2A = self.readSolarZenithAngle('T2A')        #self._sza03 = self.readSolarZenithAngle('T03')        nrL03 = scl03.shape[0]        ncL03 = scl03.shape[1]                GPM2A = zeros_like(scl2A)        GPM2A[(scl2A == bareSoils) | (scl2A == vegetation) | (scl2A == water)] = 1        if self.config.cirrusRemoval == False:            GPM2A[scl2A == cirrus] = 1        if self.config.shadowRemoval == False:            GPM2A[(scl2A == darkFeatures) | (scl2A == cloudShadows)] = 1        if  self.config.snowRemoval == False:            GPM2A[scl2A == snowIce] = 1        GP2Asum = (GPM2A[(GPM2A == 1)]).sum()        GPM03 = zeros_like(scl03)        GPM03[(scl03 == bareSoils) | (scl03 == vegetation) | (scl03 == water)] = 1        if self.config.cirrusRemoval == False:            GPM03[scl03 == cirrus] = 1        if self.config.shadowRemoval == False:            GPM03[(scl03 == darkFeatures) | (scl03 == cloudShadows)] = 1        if  self.config.snowRemoval == False:            GPM03[scl03 == snowIce] = 1        GP03sum = (GPM03[(GPM03 == 1)]).sum()                self._goodPixelRatio = float(GP03sum)/float(GP2Asum)        shape = generate_binary_structure(2,1)        GPM2A = binary_dilation(GPM2A, shape)        BPM2A = ones_like(GPM2A)        BPM2A -= GPM2A        GPM03 = binary_dilation(GPM03, shape)        BPM03 = ones_like(GPM03)        BPM03 -= GPM03                if self.config.priority == 'MOST_RECENT':            scl03[(GPM2A == 1)] = scl2A[(GPM2A == 1)]                    elif self.config.priority == 'TEMP_HOMOGENEITY':            if self._goodPixelRatio < 1.0:                scl03[(GPM2A == 1)] = scl2A[(GPM2A == 1)]                            else:                scl03[(GPM2A == 1) & (GPM03 == 0)] = scl2A[(GPM2A == 1) & (GPM03 == 0)]                    elif self.config.priority == 'RADIOMETRIC_QUALITY':            aotArr2A = self.tables.getBand('L2A', self.tables.AOT)            if (aotArr2A.shape[0] != nrL03) | (aotArr2A.shape[1] != ncL03):                aotArr2A = imresize(aotArr2A, (nrL03,ncL03), interp='nearest')                fn = self.tables._L2A_Tile_AOT_File                self.tables.setBand('L2A', self.tables.AOT, aotArr2A)                self.tables.exportBand(self.tables.AOT,fn)                   aot2Amean = (aotArr2A[scl2A != noData]).mean()                aotArr03 = self.tables.getBand('L3', self.tables.AOT)            if (aotArr03.shape[0] != nrL03) | (aotArr03.shape[1] != ncL03):                aotArr03 = imresize(aotArr03, (nrL03,ncL03), interp='nearest')                fn = self.tables._L3_Tile_AOT_File                self.tables.setBand('L3', self.tables.AOT, aotArr03)                self.tables.exportBand(self.tables.AOT,fn)            aot03mean = (aotArr03[scl03 != noData]).mean()            if aot2Amean < aot03mean:                scl03[(GPM2A == 1)] = scl2A[(GPM2A == 1)]            else:                scl03[(GPM2A == 1) & (GPM03 == 0)] = scl2A[(GPM2A == 1) & (GPM03 == 0)]        self._goodPixelMask2A = GPM2A        self._badPixelMask2A  = BPM2A        self._goodPixelMask03 = GPM03        self._badPixelMask03  = BPM03                self.tables.setBand('L3', self.tables.SCL, scl03)        return    def replaceBadPixels(self, bandIndex):        GPM2A = self._goodPixelMask2A        GPM03 = self._goodPixelMask03        BL2A = self.tables.getBand('L2A', bandIndex)        BL03 = self.tables.getBand('L3', bandIndex)        if self.config.priority == 'MOST_RECENT':            BL03[(GPM2A == 1)] = BL2A[(GPM2A == 1)]                    elif self.config.priority == 'TEMP_HOMOGENEITY':            if self._goodPixelRatio < 1.0:                BL03[(GPM2A == 1)] = BL2A[(GPM2A == 1)]              else:                BL03[(GPM2A == 1) & (GPM03 == 0)] = BL2A[(GPM2A == 1) & (GPM03 == 0)]                    elif self.config.priority == 'RADIOMETRIC_QUALITY':              scl2A = self.tables.getBand('L2A', self.tables.SCL)            aotArr2A = self.tables.getBand('L2A', self.tables.AOT)            aot2Amean = (aotArr2A[(scl2A != self._noData)]).mean()            scl03 = self.tables.getBand('L3', self.tables.SCL)            aotArr03 = self.tables.getBand('L3', self.tables.AOT)            aot03mean = (aotArr03[(scl03 != self._noData)]).mean()            if aot2Amean < aot03mean:                BL03[(GPM2A == 1)] = BL03[(GPM2A == 1)]            else:                BL03[(GPM2A == 1) & (GPM03 == 0)] = BL2A[(GPM2A == 1) & (GPM03 == 0)]        self.tables.setBand('L3', bandIndex, BL03)        return        def replaceGoodPixels(self, bandIndex):        BPM = self._badPixelMask        BL2A = self.tables.getBand('L2A', bandIndex)        BL03 = self.tables.getBand('L3', bandIndex)        SCL03 = self.tables.getBand('L3', self.tables.SCL)        nrL03 = BL03.shape[0]        ncL03 = BL03.shape[1]        BL2Ar = imresize(BL2A, (nrL03,ncL03), interp='nearest')        BL03[BPM > 0] = BL2Ar[BPM > 0]        BL03[(SCL03 == self._noData)] = 0        self.tables.setBand('L3', bandIndex, BL03)        return    def readSolarZenithAngle(self, product):        xp = L3_XmlParser(self.config, product)        ang = xp.getTree('Geometric_Info', 'Tile_Angles')        sza = float32(ang.Mean_Sun_Angle.ZENITH_ANGLE.text)        sza = absolute(sza)        if sza > 70.0: sza = 70.0        return sza            def preProcessing(self):        self.setPixelMasks()        if self.config.priority == 'MOST_RECENT':            return        elif self.config.priority == 'TEMP_HOMOGENEITY':            return        elif self.config.priority == 'RADIOMETRIC_QUALITY':            return    def forwardProcessing(self):        # this is the default processing routine: it removes clouds and dark features        # from an input image        for i in self.tables.bandIndex:            self.replaceBadPixels(i)        return True    def inverseProcessing(self):        # This is the other way round: it applies clouds and dark features        # to an input image in order to generate suitable test images.        if self.tables.testBand('L2A', 1) == False:            return False        for i in self.tables.bandIndex:            self.replaceGoodPixels(i)        return True    def postProcessing(self):        # ToDo: Implement here ...        if(self._processingStatus == False):            return False        return True        def __exit__(self):        sys.exit(-1)    def __del__(self):        self.config.logger.info('Module L3_Synthesis deleted')            def process(self):        ts = time()        self.config.timestamp('L3_Synthesis Pre-processing    ')        self.preProcessing()        #self.config.timestamp('L3_Synthesis Inverse Processing')        #self.inverseProcessing()        self.config.timestamp('L3_Synthesis Processing        ')        self.forwardProcessing()        self.config.timestamp('L3_Synthesis Post-processing   ')        self.postProcessing()        tDelta = time() - ts        self.config.logger.info('Procedure L3_Synthesis overall time [s]: %0.3f' % tDelta)        if(self.config.loglevel == 'DEBUG'):            stdoutWrite('Procedure L3_Synthesis, overall time[s]: %0.3f\n.' % tDelta)        return True